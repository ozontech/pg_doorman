<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>PgDoorman Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="css/custom.css">
        <link rel="stylesheet" href="mdbook-admonish.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PgDoorman Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ozontech/pg_doorman" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="pgdoorman-postgresql-pooler"><a class="header" href="#pgdoorman-postgresql-pooler">PgDoorman: PostgreSQL Pooler</a></h2>
<p>PgDoorman is a stable and high-performance alternative to <a href="https://www.pgbouncer.org/">PgBouncer</a>, <a href="https://github.com/yandex/odyssey">Odyssey</a>, or <a href="https://github.com/postgresml/pgcat">PgCat</a>.
It was created with the Unix philosophy in mind. Development focused on performance, efficiency, and reliability.
Additionally, PgDoorman provides improved driver support for languages like Go (pgx), .NET (npgsql), and asynchronous drivers for Python and Node.js.</p>
<p><a href="tutorials/installation.html">Get PgDoorman 3.2.4</a></p>
<h3 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h3>
<p>Run PgDoorman instantly using Docker:</p>
<pre><code class="language-bash">docker run -p 6432:6432 \
  -v $(pwd)/pg_doorman.toml:/etc/pg_doorman/pg_doorman.toml \
  ghcr.io/ozontech/pg_doorman
</code></pre>
<p><em>For more details, see the <a href="tutorials/installation.html">Installation Guide</a>.</em></p>
<h3 id="why-not-multi-pgbouncer"><a class="header" href="#why-not-multi-pgbouncer">Why not multi-PgBouncer?</a></h3>
<p>Why do we think that using <a href="https://www.pgbouncer.org/config.html#so_reuseport">multiple instances of PgBouncer</a> is not a suitable solution?
This approach has problems with reusing prepared statements and strange and inefficient control over query cancellation.
Additionally, the main issue we have encountered is that the operating system distributes new clients round-robin,
but each client can disconnect at any time, leading to an imbalance after prolonged use.</p>
<h3 id="why-not-odyssey"><a class="header" href="#why-not-odyssey">Why not Odyssey?</a></h3>
<p>We had difficulties using NPGSQL and SCRAM, as well as with <code>prepared_statements</code> support.
However, the main serious problem related to data consistency and, for a long time, we were unable to solve it.</p>
<h3 id="differences-from-pgcat"><a class="header" href="#differences-from-pgcat">Differences from PgCat</a></h3>
<p>While PgDoorman was initially based on the PgCat project, it has since evolved into a standalone solution with its own set of features.
Some of the key differences include:</p>
<ul>
<li>Performance improvements compared to PgCat/PgBouncer/Odyssey.</li>
<li>Support for extended protocol with popular programming language drivers.</li>
<li>Enhanced monitoring metrics to improve visibility into database activity.</li>
<li>Careful resource management to avoid memory issues (<code>max_memory_usage</code>, <code>message_size_to_be_stream</code>).</li>
<li>SCRAM client/server authentication support.</li>
<li><a href="tutorials/binary-upgrade.html">Gracefully binary upgrade</a>.</li>
<li>Supporting JWT for service-to-database authentication.</li>
<li>Many micro-optimizations (for example, the time spent with the client is longer than the server's busy time).</li>
</ul>
<h3 id="additional-binary-patroni_proxy"><a class="header" href="#additional-binary-patroni_proxy">Additional Binary: patroni_proxy</a></h3>
<p>This repository also includes <a href="tutorials/patroni-proxy.html">patroni_proxy</a> â€” a specialized high-performance TCP proxy for Patroni-managed PostgreSQL clusters. Unlike HAProxy + confd, it preserves existing connections during cluster topology changes and provides native role-based routing with replication lag awareness.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pgdoorman-overview"><a class="header" href="#pgdoorman-overview">PgDoorman Overview</a></h1>
<h2 id="what-is-pgdoorman"><a class="header" href="#what-is-pgdoorman">What is PgDoorman?</a></h2>
<p>PgDoorman is a high-performance PostgreSQL connection pooler based on PgCat. It acts as a middleware between your applications and PostgreSQL servers, efficiently managing database connections to improve performance and resource utilization.</p>
<pre class="mermaid">graph LR
    App1[Application A] --&gt; Pooler(PgDoorman)
    App2[Application B] --&gt; Pooler
    App3[Application C] --&gt; Pooler
    Pooler --&gt; DB[(PostgreSQL)]
</pre>
<p>When an application connects to PgDoorman, it behaves exactly like a PostgreSQL server. Behind the scenes, PgDoorman either creates a new connection to the actual PostgreSQL server or reuses an existing connection from its pool, significantly reducing connection overhead.</p>
<h2 id="key-benefits"><a class="header" href="#key-benefits">Key Benefits</a></h2>
<ul>
<li><strong>Reduced Connection Overhead</strong>: Minimizes the performance impact of establishing new database connections</li>
<li><strong>Resource Optimization</strong>: Limits the number of connections to your PostgreSQL server</li>
<li><strong>Improved Scalability</strong>: Allows more client applications to connect to your database</li>
<li><strong>Connection Management</strong>: Provides tools to monitor and manage database connections</li>
</ul>
<h2 id="pooling-modes"><a class="header" href="#pooling-modes">Pooling Modes</a></h2>
<p>To maintain proper transaction semantics while providing efficient connection pooling, PgDoorman supports multiple pooling modes:</p>
<h3 id="transaction-pooling"><a class="header" href="#transaction-pooling">Transaction Pooling</a></h3>
<div id="admonition-recommended-for-most-use-cases" class="admonition admonish-success" role="note" aria-labelledby="admonition-recommended-for-most-use-cases-title">
<div class="admonition-title">
<div id="admonition-recommended-for-most-use-cases-title">
<p>Recommended for most use cases</p>
</div>
<a class="admonition-anchor-link" href="tutorials/overview.html#admonition-recommended-for-most-use-cases"></a>
</div>
<div>
<p>In transaction pooling mode, a client is assigned a server connection only for the duration of a transaction. Once the transaction ends, the connection is released back into the pool.</p>
</div>
</div>
<ul>
<li><strong>High Efficiency</strong>: Connections are shared between clients, allowing thousands of clients to share a small pool.</li>
<li><strong>Ideal for</strong>: Applications with many short-lived connections or those that don't rely on session state.</li>
</ul>
<h3 id="session-pooling"><a class="header" href="#session-pooling">Session Pooling</a></h3>
<div id="admonition-useful-for-specific-legacy-needs" class="admonition admonish-info" role="note" aria-labelledby="admonition-useful-for-specific-legacy-needs-title">
<div class="admonition-title">
<div id="admonition-useful-for-specific-legacy-needs-title">
<p>Useful for specific legacy needs</p>
</div>
<a class="admonition-anchor-link" href="tutorials/overview.html#admonition-useful-for-specific-legacy-needs"></a>
</div>
<div>
<p>In session pooling mode, each client is assigned a dedicated server connection for the entire duration of the client connection.</p>
</div>
</div>
<ul>
<li><strong>Exclusive Allocation</strong>: The connection remains exclusively allocated to that client until disconnection.</li>
<li><strong>Support for Session Features</strong>: Ideal for applications that rely on temporary tables or session variables.</li>
</ul>
<h2 id="administration"><a class="header" href="#administration">Administration</a></h2>
<p>PgDoorman provides comprehensive tools for monitoring and management:</p>
<ul>
<li><strong>Admin Console</strong>: A PostgreSQL-compatible interface for viewing statistics and managing the pooler</li>
<li><strong>Configuration Options</strong>: Extensive settings to customize behavior for your specific needs</li>
<li><strong>Monitoring</strong>: Detailed metrics about connection usage and performance</li>
</ul>
<p>For detailed information on managing PgDoorman, see the <a href="tutorials/./basic-usage.html#admin-console">Admin Console documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-pgdoorman"><a class="header" href="#installing-pgdoorman">Installing PgDoorman</a></h1>
<p>This guide covers different methods for installing and running PgDoorman on your system.</p>
<h2 id="system-requirements"><a class="header" href="#system-requirements">System Requirements</a></h2>
<ul>
<li>Linux (recommended) or macOS</li>
<li>PostgreSQL server (version 10 or higher)</li>
<li>Sufficient memory for connection pooling (depends on expected load)</li>
</ul>
<h2 id="installation-methods"><a class="header" href="#installation-methods">Installation Methods</a></h2>
<h3 id="pre-built-binaries-recommended"><a class="header" href="#pre-built-binaries-recommended">Pre-built Binaries (Recommended)</a></h3>
<p>The simplest way to install PgDoorman is to download a pre-built binary from the <a href="https://github.com/ozontech/pg_doorman/releases">GitHub releases page</a>.</p>
<ol>
<li>Download the appropriate binary for your platform</li>
<li>Make the file executable: <code>chmod +x pg_doorman</code></li>
<li>Move it to a directory in your PATH: <code>sudo mv pg_doorman /usr/local/bin/</code></li>
<li>Create a configuration file (see <a href="tutorials/./basic-usage.html">Basic Usage</a> for details)</li>
</ol>
<h3 id="building-from-source"><a class="header" href="#building-from-source">Building from Source</a></h3>
<p>If you prefer to build from source, you'll need to clone the repository first:</p>
<pre><code class="language-bash">git clone https://github.com/ozontech/pg_doorman.git
cd pg_doorman
</code></pre>
<p>Then follow the instructions in the <a href="tutorials/./contributing.html">Contributing guide</a> to build the project.</p>
<h2 id="docker-installation"><a class="header" href="#docker-installation">Docker Installation</a></h2>
<h3 id="using-the-official-docker-image-recommended"><a class="header" href="#using-the-official-docker-image-recommended">Using the Official Docker Image (Recommended)</a></h3>
<p>PgDoorman provides an official Docker image that you can use directly:</p>
<pre><code class="language-bash"># Pull the official Docker image
docker pull ghcr.io/ozontech/pg_doorman

# Run PgDoorman with your configuration
docker run -p 6432:6432 \
  -v /path/to/pg_doorman.toml:/etc/pg_doorman/pg_doorman.toml \
  --rm -t -i ghcr.io/ozontech/pg_doorman
</code></pre>
<h3 id="using-the-dockerfile"><a class="header" href="#using-the-dockerfile">Using the Dockerfile</a></h3>
<p>You can build and run PgDoorman using Docker:</p>
<pre><code class="language-bash"># Build the Docker image
docker build -t pg_doorman -f Dockerfile .

# Run PgDoorman with your configuration
docker run -p 6432:6432 \
  -v /path/to/pg_doorman.toml:/etc/pg_doorman/pg_doorman.toml \
  --rm -t -i pg_doorman
</code></pre>
<h3 id="using-nix-with-docker"><a class="header" href="#using-nix-with-docker">Using Nix with Docker</a></h3>
<p>If you use Nix, you can build a Docker image:</p>
<pre><code class="language-bash"># Build the Docker image using Nix
nix build .#dockerImage

# Load the image into Docker
docker load -i result

# Run PgDoorman with your configuration
docker run -p 6432:6432 \
  -v /path/to/pg_doorman.toml:/etc/pg_doorman/pg_doorman.toml \
  --rm -t -i pg_doorman
</code></pre>
<h2 id="using-docker-compose-or-podman-compose"><a class="header" href="#using-docker-compose-or-podman-compose">Using Docker Compose or Podman Compose</a></h2>
<p>For a more complete setup including PostgreSQL, you can use Docker Compose or Podman Compose.</p>
<p>A minimal compose configuration file is available in the <a href="https://github.com/ozontech/pg_doorman/tree/master/example">repository examples directory</a>.</p>
<h3 id="running-with-docker-compose"><a class="header" href="#running-with-docker-compose">Running with Docker Compose</a></h3>
<pre><code class="language-bash">docker compose up -d
</code></pre>
<h3 id="running-with-podman-compose"><a class="header" href="#running-with-podman-compose">Running with Podman Compose</a></h3>
<pre><code class="language-bash">podman-compose up -d
</code></pre>
<h2 id="verifying-installation"><a class="header" href="#verifying-installation">Verifying Installation</a></h2>
<p>After installation, you can verify that PgDoorman is running correctly by:</p>
<ol>
<li>Checking the process: <code>ps aux | grep pg_doorman</code></li>
<li>Connecting to the admin console: <code>psql -h localhost -p 6432 -U admin pgdoorman</code></li>
<li>Running <code>SHOW VERSION;</code> in the admin console</li>
</ol>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>After installation, see the <a href="tutorials/./basic-usage.html">Basic Usage guide</a> to configure and start using PgDoorman.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pgdoorman-basic-usage-guide"><a class="header" href="#pgdoorman-basic-usage-guide">PgDoorman Basic Usage Guide</a></h1>
<p>PgDoorman is a high-performance PostgreSQL connection pooler based on PgCat. This comprehensive guide will help you get started with configuring, running, and managing PgDoorman for your PostgreSQL environment.</p>
<h2 id="command-line-options"><a class="header" href="#command-line-options">Command Line Options</a></h2>
<p>PgDoorman offers several command-line options to customize its behavior when starting the service:</p>
<pre><code class="language-bash">$ pg_doorman --help

PgDoorman: Nextgen PostgreSQL Pooler (based on PgCat)

Usage: pg_doorman [OPTIONS] [CONFIG_FILE] [COMMAND]

Commands:
  generate  Generate configuration for pg_doorman by connecting to PostgreSQL and auto-detecting databases and users
  help      Print this message or the help of the given subcommand(s)

Arguments:
  [CONFIG_FILE]  [env: CONFIG_FILE=] [default: pg_doorman.toml]

Options:
  -l, --log-level &lt;LOG_LEVEL&gt;    [env: LOG_LEVEL=] [default: INFO]
  -F, --log-format &lt;LOG_FORMAT&gt;  [env: LOG_FORMAT=] [default: text] [possible values: text, structured, debug]
  -n, --no-color                 disable colors in the log output [env: NO_COLOR=]
  -d, --daemon                   run as daemon [env: DAEMON=]
  -h, --help                     Print help
  -V, --version                  Print version
</code></pre>
<h3 id="available-options"><a class="header" href="#available-options">Available Options</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody>
<tr><td><code>-d</code>, <code>--daemon</code></td><td>Run in the background. Without this option, the process will run in the foreground.<br><br>In daemon mode, setting <code>daemon_pid_file</code> and <code>syslog_prog_name</code> is required. No log messages will be written to stderr after going into the background.</td></tr>
<tr><td><code>-l</code>, <code>--log-level</code></td><td>Set log level: <code>INFO</code>, <code>DEBUG</code>, or <code>WARN</code>.</td></tr>
<tr><td><code>-F</code>, <code>--log-format</code></td><td>Set log format. Possible values: <code>text</code>, <code>structured</code>, <code>debug</code>.</td></tr>
<tr><td><code>-n</code>, <code>--no-color</code></td><td>Disable colors in the log output.</td></tr>
<tr><td><code>-V</code>, <code>--version</code></td><td>Show version information.</td></tr>
<tr><td><code>-h</code>, <code>--help</code></td><td>Show help information.</td></tr>
</tbody></table>
</div>
<h2 id="setup-and-configuration"><a class="header" href="#setup-and-configuration">Setup and Configuration</a></h2>
<h3 id="configuration-file-structure"><a class="header" href="#configuration-file-structure">Configuration File Structure</a></h3>
<p>PgDoorman supports both <a href="https://yaml.org/">YAML</a> and <a href="https://toml.io/">TOML</a> configuration formats. YAML is recommended for new setups. The configuration is organized into several sections:</p>
<pre><code class="language-yaml">general:        # Global settings for the PgDoorman service
pools:
  &lt;name&gt;:       # Settings for a specific database pool
    users:
      - ...     # User settings for this pool
</code></pre>
<div id="admonition-important" class="admonition admonish-tip" role="note" aria-labelledby="admonition-important-title">
<div class="admonition-title">
<div id="admonition-important-title">
<p>Important</p>
</div>
<a class="admonition-anchor-link" href="tutorials/basic-usage.html#admonition-important"></a>
</div>
<div>
<p>Some parameters <strong>must</strong> be specified in the configuration file for PgDoorman to start, even if they have default values. For example, you must specify an admin username and password to access the administrative console.</p>
</div>
</div>
<h3 id="minimal-configuration-example"><a class="header" href="#minimal-configuration-example">Minimal Configuration Example</a></h3>
<p>Here's a minimal configuration example to get you started:</p>
<h4 id="yaml-recommended"><a class="header" href="#yaml-recommended">YAML (recommended)</a></h4>
<pre><code class="language-yaml">general:
  host: "0.0.0.0"         # Listen on all interfaces
  port: 6432               # Port for client connections
  admin_username: "admin"
  admin_password: "admin"  # Change this in production!

pools:
  exampledb:
    server_host: "127.0.0.1"  # PostgreSQL server address
    server_port: 5432          # PostgreSQL server port
    pool_mode: "transaction"   # Connection pooling mode
    users:
      - pool_size: 40
        username: "doorman"
        password: "SCRAM-SHA-256$4096:6nD+Ppi9rgaNyP7...MBiTld7xJipwG/X4="
</code></pre>
<h4 id="toml"><a class="header" href="#toml">TOML</a></h4>
<pre><code class="language-toml">[general]
host = "0.0.0.0"
port = 6432
admin_username = "admin"
admin_password = "admin"

[pools.exampledb]
server_host = "127.0.0.1"
server_port = 5432
pool_mode = "transaction"

[pools.exampledb.users.0]
pool_size = 40
username = "doorman"
password = "SCRAM-SHA-256$4096:6nD+Ppi9rgaNyP7...MBiTld7xJipwG/X4="
</code></pre>
<p>For a complete list of configuration options and their descriptions, see the <a href="tutorials/../reference/general.html">Settings Reference Guide</a>.</p>
<h3 id="automatic-configuration-generation"><a class="header" href="#automatic-configuration-generation">Automatic Configuration Generation</a></h3>
<p>PgDoorman provides a powerful <code>generate</code> command that can automatically create a configuration file by connecting to your PostgreSQL server and detecting databases and users. By default, the generated config includes detailed inline comments explaining every parameter.</p>
<pre><code class="language-bash"># View all available options
pg_doorman generate --help

# Generate a YAML configuration file (recommended)
pg_doorman generate --output pg_doorman.yaml

# Generate a TOML configuration file (for backward compatibility)
pg_doorman generate --output pg_doorman.toml

# Generate a reference config with all settings (no PG connection needed)
pg_doorman generate --reference --output pg_doorman.yaml

# Generate a reference config with Russian comments for quick start
pg_doorman generate --reference --ru --output pg_doorman.yaml

# Generate a config without comments (plain serialization)
pg_doorman generate --no-comments --output pg_doorman.yaml
</code></pre>
<p>The <code>generate</code> command supports several options:</p>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--host</code></td><td>PostgreSQL host to connect to (uses localhost if not specified)</td></tr>
<tr><td><code>--port</code>, <code>-p</code></td><td>PostgreSQL port to connect to (default: 5432)</td></tr>
<tr><td><code>--user</code>, <code>-u</code></td><td>PostgreSQL user to connect as (requires superuser privileges to read pg_shadow)</td></tr>
<tr><td><code>--password</code></td><td>PostgreSQL password to connect with</td></tr>
<tr><td><code>--database</code>, <code>-d</code></td><td>PostgreSQL database to connect to (uses same name as user if not specified)</td></tr>
<tr><td><code>--ssl</code></td><td>PostgreSQL connection to server via SSL/TLS</td></tr>
<tr><td><code>--pool-size</code></td><td>Pool size for the generated configuration (default: 40)</td></tr>
<tr><td><code>--session-pool-mode</code>, <code>-s</code></td><td>Session pool mode for the generated configuration</td></tr>
<tr><td><code>--output</code>, <code>-o</code></td><td>Output file for the generated configuration (uses stdout if not specified)</td></tr>
<tr><td><code>--server-host</code></td><td>Override server_host in config (uses the host parameter if not specified)</td></tr>
<tr><td><code>--no-comments</code></td><td>Disable inline comments in generated config (by default, comments are included)</td></tr>
<tr><td><code>--reference</code></td><td>Generate a complete reference config with example values, no PG connection needed</td></tr>
<tr><td><code>--russian-comments</code>, <code>--ru</code></td><td>Generate comments in Russian for quick start guide</td></tr>
<tr><td><code>--format</code>, <code>-f</code></td><td>Output format: <code>yaml</code> (default) or <code>toml</code>. If <code>--output</code> is specified, format is auto-detected from file extension. This flag overrides auto-detection</td></tr>
</tbody></table>
</div>
<p>The command connects to your PostgreSQL server, automatically detects all databases and users, and creates a complete, well-documented configuration file. This is especially useful for quickly setting up PgDoorman in new environments.</p>
<div id="admonition-postgresql-environment-variables" class="admonition admonish-note" role="note" aria-labelledby="admonition-postgresql-environment-variables-title">
<div class="admonition-title">
<div id="admonition-postgresql-environment-variables-title">
<p>PostgreSQL Environment Variables</p>
</div>
<a class="admonition-anchor-link" href="tutorials/basic-usage.html#admonition-postgresql-environment-variables"></a>
</div>
<div>
<p>The <code>generate</code> command also respects standard PostgreSQL environment variables like <code>PGHOST</code>, <code>PGPORT</code>, <code>PGUSER</code>, <code>PGPASSWORD</code>, and <code>PGDATABASE</code>.</p>
</div>
</div>
<div id="admonition-server-authentication-common-issue" class="admonition admonish-warning" role="note" aria-labelledby="admonition-server-authentication-common-issue-title">
<div class="admonition-title">
<div id="admonition-server-authentication-common-issue-title">
<p>Server Authentication (Common Issue)</p>
</div>
<a class="admonition-anchor-link" href="tutorials/basic-usage.html#admonition-server-authentication-common-issue"></a>
</div>
<div>
<p>By default, PgDoorman uses the same username and password for both client authentication and connecting to PostgreSQL. If you use MD5 or SCRAM password hashes for client auth (which is typical), <strong>PostgreSQL will reject the connection</strong> because it expects a plaintext password, not a hash.</p>
<p><strong>To fix this</strong>, set <code>server_username</code> and <code>server_password</code> in the user configuration:</p>
<pre><code class="language-yaml">users:
  - username: "app_user"
    password: "md5..."              # for client authentication
    server_username: "app_user"     # for PostgreSQL server
    server_password: "real_password" # plaintext password for PostgreSQL
</code></pre>
<p>The generated config includes detailed comments about this. See also <a href="tutorials/../reference/pool.html#server_username">Pool User Settings</a>.</p>
</div>
</div>
<div id="admonition-superuser-privileges" class="admonition admonish-warning" role="note" aria-labelledby="admonition-superuser-privileges-title">
<div class="admonition-title">
<div id="admonition-superuser-privileges-title">
<p>Superuser Privileges</p>
</div>
<a class="admonition-anchor-link" href="tutorials/basic-usage.html#admonition-superuser-privileges"></a>
</div>
<div>
<p>Reading user information from PostgreSQL requires superuser privileges to access the <code>pg_shadow</code> table.</p>
</div>
</div>
<h3 id="client-access-control-pg_hba"><a class="header" href="#client-access-control-pg_hba">Client access control (pg_hba)</a></h3>
<p>PgDoorman can enforce client access rules using PostgreSQL-style <code>pg_hba.conf</code> semantics via the <code>general.pg_hba</code> parameter.
You can embed rules directly in the config or reference a file path. See the <a href="tutorials/../reference/general.html#pg_hba">reference section</a> for full examples.</p>
<p>Trust mode: when a matching rule uses <code>trust</code>, PgDoorman will accept connections without prompting the client for a password,
mirroring PostgreSQL behavior. TLS-related rule types are honored: <code>hostssl</code> requires TLS, <code>hostnossl</code> forbids TLS.</p>
<h3 id="running-pgdoorman"><a class="header" href="#running-pgdoorman">Running PgDoorman</a></h3>
<p>After creating your configuration file, you can run PgDoorman from the command line:</p>
<pre><code class="language-bash">$ pg_doorman pg_doorman.toml
</code></pre>
<p>If you don't specify a configuration file, PgDoorman will look for <code>pg_doorman.toml</code> in the current directory.</p>
<h3 id="connecting-to-postgresql-via-pgdoorman"><a class="header" href="#connecting-to-postgresql-via-pgdoorman">Connecting to PostgreSQL via PgDoorman</a></h3>
<p>Once PgDoorman is running, connect to it instead of connecting directly to your PostgreSQL database:</p>
<pre><code class="language-bash">$ psql -h localhost -p 6432 -U doorman exampledb
</code></pre>
<p>Your application's connection string should be updated to point to PgDoorman instead of directly to PostgreSQL:</p>
<pre><code>postgresql://doorman:password@localhost:6432/exampledb
</code></pre>
<p>PgDoorman will handle the connection pooling transparently, so your application doesn't need to be aware that it's connecting through a pooler.</p>
<h2 id="administration-1"><a class="header" href="#administration-1">Administration</a></h2>
<h3 id="admin-console"><a class="header" href="#admin-console">Admin Console</a></h3>
<p>PgDoorman provides a powerful administrative interface that allows you to monitor and manage the connection pooler. You can access this interface by connecting to the special administration database named <strong>pgdoorman</strong>:</p>
<pre><code class="language-bash">$ psql -h localhost -p 6432 -U admin pgdoorman
</code></pre>
<p>Once connected, you can view available commands:</p>
<pre><code class="language-sql">pgdoorman=&gt; SHOW HELP;
NOTICE:  Console usage
DETAIL:
	SHOW HELP|CONFIG|DATABASES|POOLS|POOLS_EXTENDED|CLIENTS|SERVERS|USERS|VERSION
	SHOW LISTS
	SHOW CONNECTIONS
	SHOW STATS
	RELOAD
    SHUTDOWN
	SHOW
</code></pre>
<div id="admonition-protocol-compatibility" class="admonition admonish-note" role="note" aria-labelledby="admonition-protocol-compatibility-title">
<div class="admonition-title">
<div id="admonition-protocol-compatibility-title">
<p>Protocol Compatibility</p>
</div>
<a class="admonition-anchor-link" href="tutorials/basic-usage.html#admonition-protocol-compatibility"></a>
</div>
<div>
<p>The admin console currently supports only the simple query protocol.
Some database drivers use the extended query protocol for all commands, making them unsuitable for admin console access. In such cases, use the <code>psql</code> command-line client for administration.</p>
</div>
</div>
<div id="admonition-security" class="admonition admonish-warning" role="note" aria-labelledby="admonition-security-title">
<div class="admonition-title">
<div id="admonition-security-title">
<p>Security</p>
</div>
<a class="admonition-anchor-link" href="tutorials/basic-usage.html#admonition-security"></a>
</div>
<div>
<p>Only the user specified by <code>admin_username</code> in the configuration file is allowed to log in to the admin console.
If your <code>general.pg_hba</code> rules allow it, the admin console can also be accessed using the <code>trust</code> method (no password prompt), for example:</p>
<pre><code># Allow only local admin to access the admin DB without a password
host  pgdoorman  admin  127.0.0.1/32  trust
</code></pre>
<p>Use <code>trust</code> with extreme caution. Always restrict it by address and, where possible, require TLS via <code>hostssl</code>. In production, prefer password-based methods unless you fully understand the implications.</p>
</div>
</div>
<h3 id="monitoring-pgdoorman"><a class="header" href="#monitoring-pgdoorman">Monitoring PgDoorman</a></h3>
<p>The admin console provides several commands to monitor the current state of PgDoorman:</p>
<ul>
<li><code>SHOW STATS</code> - View performance statistics</li>
<li><code>SHOW CLIENTS</code> - List current client connections</li>
<li><code>SHOW SERVERS</code> - List current server connections</li>
<li><code>SHOW POOLS</code> - View connection pool status</li>
<li><code>SHOW DATABASES</code> - List configured databases</li>
<li><code>SHOW USERS</code> - List configured users</li>
</ul>
<p>These commands are described in detail in the <a href="tutorials/basic-usage.html#admin-console-commands">Admin Console Commands</a> section below.</p>
<h3 id="reloading-configuration"><a class="header" href="#reloading-configuration">Reloading Configuration</a></h3>
<p>If you make changes to the <code>pg_doorman.toml</code> file, you can apply them without restarting the service:</p>
<pre><code class="language-sql">pgdoorman=# RELOAD;
</code></pre>
<p>When you reload the configuration:</p>
<ol>
<li>PgDoorman reads the updated configuration file</li>
<li>Changes to database connection parameters are detected</li>
<li>Existing server connections are closed when they're next released (according to the pooling mode)</li>
<li>New server connections immediately use the updated parameters</li>
</ol>
<p>This allows you to make configuration changes with minimal disruption to your applications.</p>
<h2 id="admin-console-commands"><a class="header" href="#admin-console-commands">Admin Console Commands</a></h2>
<p>The admin console provides a set of commands to monitor and manage PgDoorman. These commands follow a SQL-like syntax and can be executed from any PostgreSQL client connected to the admin console.</p>
<h3 id="show-commands"><a class="header" href="#show-commands">Show Commands</a></h3>
<p>The <code>SHOW</code> commands display information about PgDoorman's operation. Each command provides different insights into the pooler's performance and current state.</p>
<h4 id="show-stats"><a class="header" href="#show-stats">SHOW STATS</a></h4>
<p>The <code>SHOW STATS</code> command displays comprehensive statistics about PgDoorman's operation:</p>
<pre><code class="language-sql">pgdoorman=&gt; SHOW STATS;
</code></pre>
<p>Statistics are presented per database with the following metrics:</p>
<div class="table-wrapper"><table><thead><tr><th>Metric</th><th>Description</th></tr></thead><tbody>
<tr><td><code>database</code></td><td>The database name these statistics apply to</td></tr>
<tr><td><code>total_xact_count</code></td><td>Total number of SQL transactions processed since startup</td></tr>
<tr><td><code>total_query_count</code></td><td>Total number of SQL commands processed since startup</td></tr>
<tr><td><code>total_received</code></td><td>Total bytes of network traffic received from clients</td></tr>
<tr><td><code>total_sent</code></td><td>Total bytes of network traffic sent to clients</td></tr>
<tr><td><code>total_xact_time</code></td><td>Total microseconds spent in transactions (including idle in transaction)</td></tr>
<tr><td><code>total_query_time</code></td><td>Total microseconds spent actively executing queries</td></tr>
<tr><td><code>total_wait_time</code></td><td>Total microseconds clients spent waiting for a server connection</td></tr>
<tr><td><code>avg_xact_count</code></td><td>Average transactions per second in the last 15-second period</td></tr>
<tr><td><code>avg_query_count</code></td><td>Average queries per second in the last 15-second period</td></tr>
<tr><td><code>avg_server_assignment_count</code></td><td>Average server assignments per second in the last 15-second period</td></tr>
<tr><td><code>avg_recv</code></td><td>Average bytes received per second from clients</td></tr>
<tr><td><code>avg_sent</code></td><td>Average bytes sent per second to clients</td></tr>
<tr><td><code>avg_xact_time</code></td><td>Average transaction duration in microseconds</td></tr>
<tr><td><code>avg_query_time</code></td><td>Average query duration in microseconds</td></tr>
<tr><td><code>avg_wait_time</code></td><td>Average time clients spent waiting for a server in microseconds</td></tr>
</tbody></table>
</div><div id="admonition-performance-monitoring" class="admonition admonish-tip" role="note" aria-labelledby="admonition-performance-monitoring-title">
<div class="admonition-title">
<div id="admonition-performance-monitoring-title">
<p>Performance Monitoring</p>
</div>
<a class="admonition-anchor-link" href="tutorials/basic-usage.html#admonition-performance-monitoring"></a>
</div>
<div>
<p>Pay special attention to the <code>avg_wait_time</code> metric. If this value is consistently high, it may indicate that your pool size is too small for your workload.</p>
</div>
</div>
<h4 id="show-servers"><a class="header" href="#show-servers">SHOW SERVERS</a></h4>
<p>The <code>SHOW SERVERS</code> command displays detailed information about all server connections:</p>
<pre><code class="language-sql">pgdoorman=&gt; SHOW SERVERS;
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Column</th><th>Description</th></tr></thead><tbody>
<tr><td><code>server_id</code></td><td>Unique identifier for the server connection</td></tr>
<tr><td><code>server_process_id</code></td><td>PID of the backend PostgreSQL server process (if available)</td></tr>
<tr><td><code>database_name</code></td><td>Name of the database this connection is using</td></tr>
<tr><td><code>user</code></td><td>Username PgDoorman uses to connect to the PostgreSQL server</td></tr>
<tr><td><code>application_name</code></td><td>Value of the <code>application_name</code> parameter set on the server connection</td></tr>
<tr><td><code>state</code></td><td>Current state of the connection: <strong>active</strong>, <strong>idle</strong>, or <strong>used</strong></td></tr>
<tr><td><code>wait</code></td><td>Wait state of the connection: <strong>idle</strong>, <strong>read</strong>, or <strong>write</strong></td></tr>
<tr><td><code>transaction_count</code></td><td>Total number of transactions processed by this connection</td></tr>
<tr><td><code>query_count</code></td><td>Total number of queries processed by this connection</td></tr>
<tr><td><code>bytes_sent</code></td><td>Total bytes sent to the PostgreSQL server</td></tr>
<tr><td><code>bytes_received</code></td><td>Total bytes received from the PostgreSQL server</td></tr>
<tr><td><code>age_seconds</code></td><td>Lifetime of the current server connection in seconds</td></tr>
<tr><td><code>prepare_cache_hit</code></td><td>Number of prepared statement cache hits</td></tr>
<tr><td><code>prepare_cache_miss</code></td><td>Number of prepared statement cache misses</td></tr>
<tr><td><code>prepare_cache_size</code></td><td>Number of unique prepared statements in the cache</td></tr>
</tbody></table>
</div><div id="admonition-connection-states" class="admonition admonish-info" role="note" aria-labelledby="admonition-connection-states-title">
<div class="admonition-title">
<div id="admonition-connection-states-title">
<p>Connection States</p>
</div>
<a class="admonition-anchor-link" href="tutorials/basic-usage.html#admonition-connection-states"></a>
</div>
<div>
<ul>
<li><strong>active</strong>: The connection is currently executing a query</li>
<li><strong>idle</strong>: The connection is available for use</li>
<li><strong>used</strong>: The connection is allocated to a client but not currently executing a query</li>
</ul>
</div>
</div>
<h4 id="show-clients"><a class="header" href="#show-clients">SHOW CLIENTS</a></h4>
<p>The <code>SHOW CLIENTS</code> command displays information about all client connections to PgDoorman:</p>
<pre><code class="language-sql">pgdoorman=&gt; SHOW CLIENTS;
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Column</th><th>Description</th></tr></thead><tbody>
<tr><td><code>client_id</code></td><td>Unique identifier for the client connection</td></tr>
<tr><td><code>database</code></td><td>Name of the database (pool) the client is connected to</td></tr>
<tr><td><code>user</code></td><td>Username the client used to connect</td></tr>
<tr><td><code>addr</code></td><td>Client's IP address and port (IP:port)</td></tr>
<tr><td><code>tls</code></td><td>Whether the connection uses TLS encryption (<strong>true</strong> or <strong>false</strong>)</td></tr>
<tr><td><code>state</code></td><td>Current state of the client connection: <strong>active</strong>, <strong>idle</strong>, or <strong>waiting</strong></td></tr>
<tr><td><code>wait</code></td><td>Wait state of the client connection: <strong>idle</strong>, <strong>read</strong>, or <strong>write</strong></td></tr>
<tr><td><code>transaction_count</code></td><td>Total number of transactions processed for this client</td></tr>
<tr><td><code>query_count</code></td><td>Total number of queries processed for this client</td></tr>
<tr><td><code>age_seconds</code></td><td>Lifetime of the client connection in seconds</td></tr>
</tbody></table>
</div><div id="admonition-monitoring-long-running-connections" class="admonition admonish-tip" role="note" aria-labelledby="admonition-monitoring-long-running-connections-title">
<div class="admonition-title">
<div id="admonition-monitoring-long-running-connections-title">
<p>Monitoring Long-Running Connections</p>
</div>
<a class="admonition-anchor-link" href="tutorials/basic-usage.html#admonition-monitoring-long-running-connections"></a>
</div>
<div>
<p>The <code>age_seconds</code> column can help identify long-running connections that might be holding resources unnecessarily. Consider implementing connection timeouts in your application for idle connections.</p>
</div>
</div>
<h4 id="show-pools"><a class="header" href="#show-pools">SHOW POOLS</a></h4>
<p>The <code>SHOW POOLS</code> command displays information about connection pools. A new pool entry is created for each (database, user) pair:</p>
<pre><code class="language-sql">pgdoorman=&gt; SHOW POOLS;
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Column</th><th>Description</th></tr></thead><tbody>
<tr><td><code>database</code></td><td>Name of the database</td></tr>
<tr><td><code>user</code></td><td>Username associated with this pool</td></tr>
<tr><td><code>pool_mode</code></td><td>Pooling mode in use: <strong>session</strong> or <strong>transaction</strong></td></tr>
<tr><td><code>cl_active</code></td><td>Number of active client connections (linked to servers or idle)</td></tr>
<tr><td><code>cl_waiting</code></td><td>Number of client connections waiting for a server connection</td></tr>
<tr><td><code>sv_active</code></td><td>Number of server connections linked to clients</td></tr>
<tr><td><code>sv_idle</code></td><td>Number of idle server connections available for immediate use</td></tr>
<tr><td><code>sv_login</code></td><td>Number of server connections currently in the login process</td></tr>
<tr><td><code>maxwait</code></td><td>Maximum wait time in seconds for the oldest client in the queue</td></tr>
<tr><td><code>maxwait_us</code></td><td>Microsecond part of the maximum waiting time</td></tr>
</tbody></table>
</div><div id="admonition-performance-alert" class="admonition admonish-warning" role="note" aria-labelledby="admonition-performance-alert-title">
<div class="admonition-title">
<div id="admonition-performance-alert-title">
<p>Performance Alert</p>
</div>
<a class="admonition-anchor-link" href="tutorials/basic-usage.html#admonition-performance-alert"></a>
</div>
<div>
<p>If the <code>maxwait</code> value starts increasing, your server pool may not be handling requests quickly enough. This could be due to an overloaded PostgreSQL server or insufficient <code>pool_size</code> setting.</p>
</div>
</div>
<h4 id="show-users"><a class="header" href="#show-users">SHOW USERS</a></h4>
<p>The <code>SHOW USERS</code> command displays information about all configured users:</p>
<pre><code class="language-sql">pgdoorman=&gt; SHOW USERS;
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Column</th><th>Description</th></tr></thead><tbody>
<tr><td><code>name</code></td><td>Username as configured in PgDoorman</td></tr>
<tr><td><code>pool_mode</code></td><td>Pooling mode assigned to this user: <strong>session</strong> or <strong>transaction</strong></td></tr>
</tbody></table>
</div>
<h4 id="show-databases"><a class="header" href="#show-databases">SHOW DATABASES</a></h4>
<p>The <code>SHOW DATABASES</code> command displays information about all configured database pools:</p>
<pre><code class="language-sql">pgdoorman=&gt; SHOW DATABASES;
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Column</th><th>Description</th></tr></thead><tbody>
<tr><td><code>database</code></td><td>Name of the configured database pool</td></tr>
<tr><td><code>host</code></td><td>Hostname of the PostgreSQL server PgDoorman connects to</td></tr>
<tr><td><code>port</code></td><td>Port number of the PostgreSQL server</td></tr>
<tr><td><code>pool_size</code></td><td>Maximum number of server connections for this database</td></tr>
<tr><td><code>min_pool_size</code></td><td>Minimum number of server connections to maintain</td></tr>
<tr><td><code>reserve_pool_size</code></td><td>Maximum number of additional connections allowed</td></tr>
<tr><td><code>pool_mode</code></td><td>Default pooling mode for this database</td></tr>
<tr><td><code>max_connections</code></td><td>Maximum allowed server connections (from <code>max_db_connections</code>)</td></tr>
<tr><td><code>current_connections</code></td><td>Current number of server connections for this database</td></tr>
</tbody></table>
</div><div id="admonition-connection-management" class="admonition admonish-tip" role="note" aria-labelledby="admonition-connection-management-title">
<div class="admonition-title">
<div id="admonition-connection-management-title">
<p>Connection Management</p>
</div>
<a class="admonition-anchor-link" href="tutorials/basic-usage.html#admonition-connection-management"></a>
</div>
<div>
<p>Monitor the ratio between <code>current_connections</code> and <code>pool_size</code> to ensure your pool is properly sized. If <code>current_connections</code> frequently reaches <code>pool_size</code>, consider increasing the pool size.</p>
</div>
</div>
<h4 id="show-sockets"><a class="header" href="#show-sockets">SHOW SOCKETS</a></h4>
<p>The <code>SHOW SOCKETS</code> command displays low-level information about network sockets:</p>
<pre><code class="language-sql">pgdoorman=&gt; SHOW SOCKETS;
</code></pre>
<p>This command includes all information shown in <code>SHOW CLIENTS</code> and <code>SHOW SERVERS</code> plus additional low-level details about the socket connections.</p>
<h4 id="show-version"><a class="header" href="#show-version">SHOW VERSION</a></h4>
<p>The <code>SHOW VERSION</code> command displays the PgDoorman version information:</p>
<pre><code class="language-sql">pgdoorman=&gt; SHOW VERSION;
</code></pre>
<p>This is useful for verifying which version you're running, especially after upgrades.</p>
<h3 id="control-commands"><a class="header" href="#control-commands">Control Commands</a></h3>
<p>PgDoorman provides control commands that allow you to manage the service operation directly from the admin console.</p>
<h4 id="shutdown"><a class="header" href="#shutdown">SHUTDOWN</a></h4>
<p>The <code>SHUTDOWN</code> command gracefully terminates the PgDoorman process:</p>
<pre><code class="language-sql">pgdoorman=&gt; SHUTDOWN;
</code></pre>
<p>When executed:</p>
<ol>
<li>PgDoorman stops accepting new client connections</li>
<li>Existing transactions are allowed to complete (within the configured timeout)</li>
<li>All connections are closed</li>
<li>The process exits</li>
</ol>
<div id="admonition-service-interruption" class="admonition admonish-warning" role="note" aria-labelledby="admonition-service-interruption-title">
<div class="admonition-title">
<div id="admonition-service-interruption-title">
<p>Service Interruption</p>
</div>
<a class="admonition-anchor-link" href="tutorials/basic-usage.html#admonition-service-interruption"></a>
</div>
<div>
<p>Using the <code>SHUTDOWN</code> command will terminate the PgDoorman service, disconnecting all clients. Use this command with caution in production environments.</p>
</div>
</div>
<h4 id="reload"><a class="header" href="#reload">RELOAD</a></h4>
<p>The <code>RELOAD</code> command refreshes PgDoorman's configuration without restarting the service:</p>
<pre><code class="language-sql">pgdoorman=&gt; RELOAD;
</code></pre>
<p>This command:</p>
<ol>
<li>Rereads the configuration file</li>
<li>Updates all changeable settings</li>
<li>Applies changes to connection parameters for new connections</li>
<li>Maintains existing connections until they're released back to the pool</li>
</ol>
<div id="admonition-zero-downtime-configuration-changes" class="admonition admonish-tip" role="note" aria-labelledby="admonition-zero-downtime-configuration-changes-title">
<div class="admonition-title">
<div id="admonition-zero-downtime-configuration-changes-title">
<p>Zero-Downtime Configuration Changes</p>
</div>
<a class="admonition-anchor-link" href="tutorials/basic-usage.html#admonition-zero-downtime-configuration-changes"></a>
</div>
<div>
<p>The <code>RELOAD</code> command allows you to modify most configuration parameters without disrupting existing connections. This is ideal for production environments where downtime must be minimized.</p>
</div>
</div>
<h2 id="signal-handling"><a class="header" href="#signal-handling">Signal Handling</a></h2>
<p>PgDoorman responds to standard Unix signals for control and management. These signals can be sent using the <code>kill</code> command (e.g., <code>kill -HUP &lt;pid&gt;</code>).</p>
<div class="table-wrapper"><table><thead><tr><th>Signal</th><th>Description</th><th>Effect</th></tr></thead><tbody>
<tr><td><strong>SIGHUP</strong></td><td>Configuration reload</td><td>Equivalent to the <code>RELOAD</code> command in the admin console. Rereads the configuration file and applies changes to settings.</td></tr>
<tr><td><strong>SIGTERM</strong></td><td>Immediate shutdown</td><td>Forces PgDoorman to exit immediately. Active connections may be terminated abruptly.</td></tr>
<tr><td><strong>SIGINT</strong></td><td>Graceful shutdown</td><td>Initiates a binary upgrade process. The current process starts a new instance and gracefully transfers connections. See <a href="tutorials/binary-upgrade.html">Binary Upgrade Process</a> for details.</td></tr>
</tbody></table>
</div><div id="admonition-process-management" class="admonition admonish-note" role="note" aria-labelledby="admonition-process-management-title">
<div class="admonition-title">
<div id="admonition-process-management-title">
<p>Process Management</p>
</div>
<a class="admonition-anchor-link" href="tutorials/basic-usage.html#admonition-process-management"></a>
</div>
<div>
<p>In systemd-based environments, you can use <code>systemctl reload pg_doorman</code> to send SIGHUP and <code>systemctl restart pg_doorman</code> for a complete restart.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binary-upgrade-process"><a class="header" href="#binary-upgrade-process">Binary Upgrade Process</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>PgDoorman supports seamless binary upgrades that allow you to update the software with minimal disruption to your database connections. This document explains how the upgrade process works and what to expect during an upgrade.</p>
<h2 id="how-the-upgrade-process-works"><a class="header" href="#how-the-upgrade-process-works">How the Upgrade Process Works</a></h2>
<p>When you send a <code>SIGINT</code> signal to the PgDoorman process, the binary upgrade process is initiated:</p>
<ol>
<li>The current PgDoorman instance executes the exec command and starts a new, daemonized process</li>
<li>The new process uses the <code>SO_REUSE_PORT</code> socket option, allowing the operating system to distribute incoming traffic to the new instance</li>
<li>The old instance then closes its socket for incoming connections</li>
<li>Existing connections are handled gracefully during the transition</li>
</ol>
<h2 id="handling-existing-connections"><a class="header" href="#handling-existing-connections">Handling Existing Connections</a></h2>
<p>During the upgrade process, PgDoorman handles existing connections as follows:</p>
<ol>
<li>Current queries and transactions are allowed to complete within the specified <code>shutdown_timeout</code> (default: 10 seconds)</li>
<li>After each query or transaction completes successfully, PgDoorman returns error code <code>58006</code> to the client</li>
<li>This error code indicates to the client that they need to reconnect to the server</li>
<li>After reconnecting, clients can safely retry their queries with the new PgDoorman instance</li>
</ol>
<h2 id="important-considerations"><a class="header" href="#important-considerations">Important Considerations</a></h2>
<div id="admonition-query-repetition" class="admonition admonish-warning" role="note" aria-labelledby="admonition-query-repetition-title">
<div class="admonition-title">
<div id="admonition-query-repetition-title">
<p>Query Repetition</p>
</div>
<a class="admonition-anchor-link" href="tutorials/binary-upgrade.html#admonition-query-repetition"></a>
</div>
<div>
<p>Repeating a query without receiving error code <code>58006</code> may cause problems as described in <a href="https://github.com/lib/pq/issues/939">this issue</a>. Make sure your client application properly handles reconnection scenarios.</p>
</div>
</div>
<div id="admonition-client-library-compatibility" class="admonition admonish-tip" role="note" aria-labelledby="admonition-client-library-compatibility-title">
<div class="admonition-title">
<div id="admonition-client-library-compatibility-title">
<p>Client Library Compatibility</p>
</div>
<a class="admonition-anchor-link" href="tutorials/binary-upgrade.html#admonition-client-library-compatibility"></a>
</div>
<div>
<p>Be careful when using client libraries like <code>github.com/lib/pq</code> or Go's standard <code>database/sql</code> package. Ensure they properly handle the reconnection process during binary upgrades.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="patroni-proxy"><a class="header" href="#patroni-proxy">Patroni Proxy</a></h1>
<p><code>patroni_proxy</code> is a specialized high-performance TCP proxy for Patroni-managed PostgreSQL clusters. Following the Unix philosophy of "do one thing and do it well", it focuses exclusively on TCP load balancing and failover for Patroni clusters.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>Unlike traditional solutions like HAProxy, <code>patroni_proxy</code> provides seamless connection management without disrupting existing connections during cluster topology changes. When a new replica is added or removed, only the affected connections are handled â€” all other connections continue working without interruption.</p>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<h3 id="zero-downtime-connection-management"><a class="header" href="#zero-downtime-connection-management">Zero-Downtime Connection Management</a></h3>
<p>The main advantage over HAProxy is that <code>patroni_proxy</code> <strong>does not terminate existing connections</strong> when the upstream configuration changes. This is critical for long-running transactions and connection-heavy applications.</p>
<h3 id="hot-upstream-updates"><a class="header" href="#hot-upstream-updates">Hot Upstream Updates</a></h3>
<ul>
<li>Automatic discovery of cluster members via Patroni REST API (<code>/cluster</code> endpoint)</li>
<li>Periodic polling with configurable interval (<code>cluster_update_interval</code>)</li>
<li>Immediate updates via HTTP API (<code>/update_clusters</code> endpoint)</li>
<li>Configuration reload via SIGHUP signal without restart</li>
</ul>
<h3 id="role-based-routing"><a class="header" href="#role-based-routing">Role-Based Routing</a></h3>
<p>Route connections based on PostgreSQL node roles:</p>
<div class="table-wrapper"><table><thead><tr><th>Role</th><th>Description</th></tr></thead><tbody>
<tr><td><code>leader</code></td><td>Primary/master node</td></tr>
<tr><td><code>sync</code></td><td>Synchronous standby replicas</td></tr>
<tr><td><code>async</code></td><td>Asynchronous replicas</td></tr>
<tr><td><code>any</code></td><td>Any available node</td></tr>
</tbody></table>
</div>
<h3 id="intelligent-load-balancing"><a class="header" href="#intelligent-load-balancing">Intelligent Load Balancing</a></h3>
<ul>
<li><strong>Least Connections</strong> strategy for distributing connections across backends</li>
<li>Connection counters are preserved during cluster updates</li>
<li>Automatic exclusion of nodes with <code>noloadbalance</code> tag</li>
</ul>
<h3 id="replication-lag-awareness"><a class="header" href="#replication-lag-awareness">Replication Lag Awareness</a></h3>
<ul>
<li>Configurable <code>max_lag_in_bytes</code> per port</li>
<li>Automatic disconnection of clients when replica lag exceeds threshold</li>
<li>Only affects replica connections (leader has no lag)</li>
</ul>
<h3 id="member-state-filtering"><a class="header" href="#member-state-filtering">Member State Filtering</a></h3>
<ul>
<li>Only members with <code>state: "running"</code> are used as backends</li>
<li>Members in <code>starting</code>, <code>stopped</code>, <code>crashed</code> states are automatically excluded</li>
<li>Dynamic state changes are handled during periodic updates</li>
</ul>
<h2 id="recommended-deployment-architecture"><a class="header" href="#recommended-deployment-architecture">Recommended Deployment Architecture</a></h2>
<p>For optimal performance, we recommend a two-tier architecture:</p>
<pre class="mermaid">graph TD
    App1[Application A] --&gt; PP(patroni_proxy&lt;br/&gt;TCP load balancing)
    App2[Application B] --&gt; PP
    App3[Application C] --&gt; PP

    PP --&gt; D1(pg_doorman&lt;br/&gt;pooling)
    PP --&gt; D2(pg_doorman&lt;br/&gt;pooling)
    PP --&gt; D3(pg_doorman&lt;br/&gt;pooling)

    D1 --&gt; PG1[(PostgreSQL&lt;br/&gt;leader)]
    D2 --&gt; PG2[(PostgreSQL&lt;br/&gt;sync replica)]
    D3 --&gt; PG3[(PostgreSQL&lt;br/&gt;async replica)]
</pre>
<ul>
<li><strong>pg_doorman</strong> should be deployed <strong>close to PostgreSQL servers</strong> â€” it handles connection pooling, prepared statement caching, and protocol-level optimizations that benefit from low latency to the database</li>
<li><strong>patroni_proxy</strong> should be deployed <strong>close to application clients</strong> â€” it handles TCP routing and failover, distributing connections across the cluster without the overhead of connection pooling</li>
</ul>
<p>This separation allows each component to excel at its specific task while providing both high availability and optimal performance.</p>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>Example <code>patroni_proxy.yaml</code>:</p>
<pre><code class="language-yaml"># Cluster update interval in seconds (default: 3)
cluster_update_interval: 3

# HTTP API listen address for health checks and manual updates (default: 127.0.0.1:8009)
listen_address: "127.0.0.1:8009"

clusters:
  my_cluster:
    # Patroni API endpoints (multiple for redundancy)
    hosts:
      - "http://192.168.1.1:8008"
      - "http://192.168.1.2:8008"
      - "http://192.168.1.3:8008"
    
    # Optional: TLS configuration for Patroni API
    # tls:
    #   ca_cert: "/path/to/ca.crt"
    #   client_cert: "/path/to/client.crt"
    #   client_key: "/path/to/client.key"
    #   skip_verify: false
    
    ports:
      # Primary/master connections
      master:
        listen: "0.0.0.0:6432"
        roles: ["leader"]
        host_port: 5432
      
      # Read-only connections to replicas
      replicas:
        listen: "0.0.0.0:6433"
        roles: ["sync", "async"]
        host_port: 5432
        max_lag_in_bytes: 16777216  # 16MB
</code></pre>
<h3 id="configuration-options"><a class="header" href="#configuration-options">Configuration Options</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>cluster_update_interval</code></td><td>3</td><td>Interval in seconds between Patroni API polls</td></tr>
<tr><td><code>listen_address</code></td><td>127.0.0.1:8009</td><td>HTTP API listen address</td></tr>
<tr><td><code>clusters.&lt;name&gt;.hosts</code></td><td>-</td><td>List of Patroni API endpoints</td></tr>
<tr><td><code>clusters.&lt;name&gt;.tls</code></td><td>-</td><td>Optional TLS configuration for Patroni API</td></tr>
<tr><td><code>clusters.&lt;name&gt;.ports.&lt;name&gt;.listen</code></td><td>-</td><td>Listen address for this port</td></tr>
<tr><td><code>clusters.&lt;name&gt;.ports.&lt;name&gt;.roles</code></td><td>-</td><td>List of allowed roles</td></tr>
<tr><td><code>clusters.&lt;name&gt;.ports.&lt;name&gt;.host_port</code></td><td>-</td><td>PostgreSQL port on backend hosts</td></tr>
<tr><td><code>clusters.&lt;name&gt;.ports.&lt;name&gt;.max_lag_in_bytes</code></td><td>-</td><td>Maximum replication lag (optional)</td></tr>
</tbody></table>
</div>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<h3 id="starting-patroni_proxy"><a class="header" href="#starting-patroni_proxy">Starting patroni_proxy</a></h3>
<pre><code class="language-bash"># Start with configuration file
patroni_proxy /path/to/patroni_proxy.yaml

# With debug logging
RUST_LOG=debug patroni_proxy /path/to/patroni_proxy.yaml
</code></pre>
<h3 id="configuration-reload"><a class="header" href="#configuration-reload">Configuration Reload</a></h3>
<p>Reload configuration without restart (add/remove ports, update hosts):</p>
<pre><code class="language-bash">kill -HUP $(pidof patroni_proxy)
</code></pre>
<h3 id="manual-cluster-update"><a class="header" href="#manual-cluster-update">Manual Cluster Update</a></h3>
<p>Trigger immediate update of all cluster members via HTTP API:</p>
<pre><code class="language-bash">curl http://127.0.0.1:8009/update_clusters
</code></pre>
<h2 id="http-api"><a class="header" href="#http-api">HTTP API</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Endpoint</th><th>Method</th><th>Description</th></tr></thead><tbody>
<tr><td><code>/update_clusters</code></td><td>GET</td><td>Trigger immediate update of all cluster members</td></tr>
<tr><td><code>/</code></td><td>GET</td><td>Health check (returns "OK")</td></tr>
</tbody></table>
</div>
<h2 id="comparison-with-haproxy--confd"><a class="header" href="#comparison-with-haproxy--confd">Comparison with HAProxy + confd</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>patroni_proxy</th><th>HAProxy + confd</th></tr></thead><tbody>
<tr><td>Connection preservation on update</td><td>âœ… Yes</td><td>âŒ No (reload drops connections)</td></tr>
<tr><td>Hot upstream updates</td><td>âœ… Native</td><td>âš ï¸ Requires confd + reload</td></tr>
<tr><td>Replication lag awareness</td><td>âœ… Built-in</td><td>âš ï¸ Requires custom checks</td></tr>
<tr><td>Configuration complexity</td><td>âœ… Single YAML</td><td>âŒ Multiple configs</td></tr>
<tr><td>Resource usage</td><td>âœ… Lightweight</td><td>âš ï¸ HAProxy + confd processes</td></tr>
<tr><td>Role-based routing</td><td>âœ… Native</td><td>âš ï¸ Requires custom templates</td></tr>
</tbody></table>
</div>
<h2 id="building"><a class="header" href="#building">Building</a></h2>
<pre><code class="language-bash"># Build release binary
cargo build --release --bin patroni_proxy

# Run tests
cargo test --test patroni_proxy_bdd
</code></pre>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="no-backends-available"><a class="header" href="#no-backends-available">No backends available</a></h3>
<p>If you see warnings like <code>no backends available</code>, check:</p>
<ol>
<li>Patroni API is accessible from patroni_proxy host</li>
<li>Cluster members have <code>state: "running"</code></li>
<li>Roles in configuration match actual member roles</li>
<li>If using <code>max_lag_in_bytes</code>, check replica lag values</li>
</ol>
<h3 id="connection-drops-after-update"><a class="header" href="#connection-drops-after-update">Connection drops after update</a></h3>
<p>This should not happen with patroni_proxy. If connections are being dropped:</p>
<ol>
<li>Check if the backend host was actually removed from the cluster</li>
<li>Verify <code>max_lag_in_bytes</code> threshold is not being exceeded</li>
<li>Enable debug logging to see detailed connection lifecycle</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h1>
<p>This guide helps you resolve common issues when using PgDoorman.</p>
<h2 id="authentication-errors-when-connecting-to-postgresql"><a class="header" href="#authentication-errors-when-connecting-to-postgresql">Authentication Errors When Connecting to PostgreSQL</a></h2>
<p><strong>Symptom:</strong> PgDoorman starts successfully but clients get authentication errors like <code>password authentication failed</code> when trying to execute queries.</p>
<p><strong>Cause:</strong> By default, PgDoorman uses the same <code>username</code> and <code>password</code> for both client authentication and connecting to the PostgreSQL server. If the <code>password</code> field contains an MD5 or SCRAM hash (which is the typical and recommended setup), PostgreSQL will reject it because it expects a plaintext password.</p>
<p><strong>Solution:</strong> Set <code>server_username</code> and <code>server_password</code> in your user configuration to the actual PostgreSQL credentials:</p>
<h3 id="yaml"><a class="header" href="#yaml">YAML</a></h3>
<pre><code class="language-yaml">pools:
  mydb:
    server_host: "127.0.0.1"
    server_port: 5432
    users:
      - username: "app_user"
        password: "md5..."                # MD5/SCRAM hash for client auth
        server_username: "app_user"       # real PostgreSQL username
        server_password: "plaintext_pwd"  # real PostgreSQL password
        pool_size: 40
</code></pre>
<h3 id="toml-1"><a class="header" href="#toml-1">TOML</a></h3>
<pre><code class="language-toml">[pools.mydb.users.0]
username = "app_user"
password = "md5..."                # MD5/SCRAM hash for client auth
server_username = "app_user"       # real PostgreSQL username
server_password = "plaintext_pwd"  # real PostgreSQL password
pool_size = 40
</code></pre>
<div id="admonition-how-to-get-the-password-hash" class="admonition admonish-tip" role="note" aria-labelledby="admonition-how-to-get-the-password-hash-title">
<div class="admonition-title">
<div id="admonition-how-to-get-the-password-hash-title">
<p>How to get the password hash</p>
</div>
<a class="admonition-anchor-link" href="tutorials/troubleshooting.html#admonition-how-to-get-the-password-hash"></a>
</div>
<div>
<p>You can get user password hashes from PostgreSQL using: <code>SELECT usename, passwd FROM pg_shadow;</code></p>
<p>Or use the <code>pg_doorman generate</code> command which automatically retrieves them.</p>
</div>
</div>
<h2 id="configuration-file-not-found"><a class="header" href="#configuration-file-not-found">Configuration File Not Found</a></h2>
<p><strong>Symptom:</strong> PgDoorman exits with "configuration file not found" error.</p>
<p><strong>Solution:</strong> Specify the configuration file path explicitly:</p>
<pre><code class="language-bash">pg_doorman /path/to/pg_doorman.yaml
</code></pre>
<p>By default, PgDoorman looks for <code>pg_doorman.toml</code> in the current directory.</p>
<h2 id="pool-size-too-small"><a class="header" href="#pool-size-too-small">Pool Size Too Small</a></h2>
<p><strong>Symptom:</strong> Clients experience high wait times or receive errors about too many connections.</p>
<p><strong>Solution:</strong> Increase <code>pool_size</code> for the affected user, or check the <code>SHOW POOLS</code> admin command to see <code>cl_waiting</code> and <code>maxwait</code> values. If <code>maxwait</code> is consistently high, your pool is undersized for your workload.</p>
<hr />
<div id="admonition-still-having-issues" class="admonition admonish-tip" role="note" aria-labelledby="admonition-still-having-issues-title">
<div class="admonition-title">
<div id="admonition-still-having-issues-title">
<p>Still having issues?</p>
</div>
<a class="admonition-anchor-link" href="tutorials/troubleshooting.html#admonition-still-having-issues"></a>
</div>
<div>
<p>If you encounter a problem not listed here, please <a href="https://github.com/ozontech/pg_doorman/issues">open an issue on GitHub</a>.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="settings"><a class="header" href="#settings">Settings</a></h1>
<h2 id="configuration-file-format"><a class="header" href="#configuration-file-format">Configuration File Format</a></h2>
<p>pg_doorman supports two configuration file formats:</p>
<ul>
<li><strong>YAML</strong> (<code>.yaml</code>, <code>.yml</code>) - The primary and recommended format for new configurations.</li>
<li><strong>TOML</strong> (<code>.toml</code>) - Supported for backward compatibility with existing configurations.</li>
</ul>
<p>The format is automatically detected based on the file extension. Both formats support the same configuration options and can be used interchangeably.</p>
<h3 id="example-yaml-configuration-recommended"><a class="header" href="#example-yaml-configuration-recommended">Example YAML Configuration (Recommended)</a></h3>
<pre><code class="language-yaml">general:
  host: "0.0.0.0"
  port: 6432
  admin_username: "admin"
  admin_password: "admin"

pools:
  mydb:
    server_host: "localhost"
    server_port: 5432
    pool_mode: "transaction"
    users:
      - username: "myuser"
        password: "mypassword"
        pool_size: 40
</code></pre>
<h3 id="example-toml-configuration-legacy"><a class="header" href="#example-toml-configuration-legacy">Example TOML Configuration (Legacy)</a></h3>
<pre><code class="language-toml">[general]
host = "0.0.0.0"
port = 6432
admin_username = "admin"
admin_password = "admin"

[pools.mydb]
server_host = "localhost"
server_port = 5432
pool_mode = "transaction"

[[pools.mydb.users]]
username = "myuser"
password = "mypassword"
pool_size = 40
</code></pre>
<h3 id="generate-command"><a class="header" href="#generate-command">Generate Command</a></h3>
<p>The <code>generate</code> command can output configuration in either format. The format is determined by the output file extension. By default, the generated config includes detailed inline comments explaining every parameter.</p>
<pre><code class="language-bash"># Generate YAML configuration (recommended)
pg_doorman generate --output config.yaml

# Generate TOML configuration (for backward compatibility)
pg_doorman generate --output config.toml

# Generate a complete reference config without PG connection
pg_doorman generate --reference --output config.yaml

# Generate reference config with Russian comments
pg_doorman generate --reference --ru --output config.yaml

# Generate config without comments (plain serialization)
pg_doorman generate --no-comments --output config.yaml
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Flag</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--no-comments</code></td><td>Disable inline comments in generated config (by default, comments are included)</td></tr>
<tr><td><code>--reference</code></td><td>Generate a complete reference config with example values, no PostgreSQL connection needed</td></tr>
<tr><td><code>--russian-comments</code>, <code>--ru</code></td><td>Generate comments in Russian for quick start guide</td></tr>
<tr><td><code>--format</code>, <code>-f</code></td><td>Output format: <code>yaml</code> (default) or <code>toml</code>. If <code>--output</code> is specified, format is auto-detected from file extension. This flag overrides auto-detection</td></tr>
</tbody></table>
</div>
<h3 id="include-files"><a class="header" href="#include-files">Include Files</a></h3>
<p>Include files can be in either format, and you can mix formats. For example, a YAML main config can include TOML files and vice versa:</p>
<pre><code class="language-yaml">include:
  files:
    - "pools.yaml"
    - "users.toml"
</code></pre>
<h2 id="human-readable-values"><a class="header" href="#human-readable-values">Human-Readable Values</a></h2>
<p>pg_doorman supports human-readable formats for duration and byte size values, while maintaining backward compatibility with numeric values.</p>
<h3 id="duration-format"><a class="header" href="#duration-format">Duration Format</a></h3>
<p>Duration values can be specified as:</p>
<ul>
<li><strong>Plain numbers</strong>: interpreted as milliseconds (e.g., <code>5000</code> = 5 seconds)</li>
<li><strong>String with suffix</strong>:
<ul>
<li><code>ms</code> - milliseconds (e.g., <code>"100ms"</code>)</li>
<li><code>s</code> - seconds (e.g., <code>"5s"</code> = 5000 milliseconds)</li>
<li><code>m</code> - minutes (e.g., <code>"5m"</code> = 300000 milliseconds)</li>
<li><code>h</code> - hours (e.g., <code>"1h"</code> = 3600000 milliseconds)</li>
<li><code>d</code> - days (e.g., <code>"1d"</code> = 86400000 milliseconds)</li>
</ul>
</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-yaml">general:
  # All these are equivalent (3 seconds):
  # connect_timeout: 3000      # backward compatible (milliseconds)
  # connect_timeout: "3s"      # human-readable
  # connect_timeout: "3000ms"  # explicit milliseconds
  connect_timeout: "3s"
  idle_timeout: "5m"         # 5 minutes
  server_lifetime: "1h"      # 1 hour
</code></pre>
<h3 id="byte-size-format"><a class="header" href="#byte-size-format">Byte Size Format</a></h3>
<p>Byte size values can be specified as:</p>
<ul>
<li><strong>Plain numbers</strong>: interpreted as bytes (e.g., <code>1048576</code> = 1 MB)</li>
<li><strong>String with suffix</strong> (case-insensitive):
<ul>
<li><code>B</code> - bytes (e.g., <code>"1024B"</code>)</li>
<li><code>K</code> or <code>KB</code> - kilobytes (e.g., <code>"1K"</code> or <code>"1KB"</code> = 1024 bytes)</li>
<li><code>M</code> or <code>MB</code> - megabytes (e.g., <code>"1M"</code> or <code>"1MB"</code> = 1048576 bytes)</li>
<li><code>G</code> or <code>GB</code> - gigabytes (e.g., <code>"1G"</code> or <code>"1GB"</code> = 1073741824 bytes)</li>
</ul>
</li>
</ul>
<p>Note: Uses binary prefixes (1 KB = 1024 bytes, not 1000 bytes).</p>
<p><strong>Examples:</strong></p>
<pre><code class="language-yaml">general:
  # All these are equivalent (256 MB):
  # max_memory_usage: 268435456  # backward compatible (bytes)
  # max_memory_usage: "256MB"    # human-readable
  # max_memory_usage: "256M"     # short form
  max_memory_usage: "256MB"
  unix_socket_buffer_size: "1MB" # 1 MB
  worker_stack_size: "8MB"       # 8 MB
</code></pre>
<h2 id="general-settings"><a class="header" href="#general-settings">General Settings</a></h2>
<h3 id="host"><a class="header" href="#host">host</a></h3>
<p>Listen host (TCP v4 only).</p>
<p>Default: <code>"0.0.0.0"</code>.</p>
<h3 id="port"><a class="header" href="#port">port</a></h3>
<p>Listen port for incoming connections.</p>
<p>Default: <code>5432</code>.</p>
<h3 id="backlog"><a class="header" href="#backlog">backlog</a></h3>
<p>TCP backlog for incoming connections. A value of zero sets the <code>max_connections</code> as value for the TCP backlog.</p>
<p>Default: <code>0</code>.</p>
<h3 id="max_connections"><a class="header" href="#max_connections">max_connections</a></h3>
<p>The maximum number of clients that can connect to the pooler simultaneously. When this limit is reached:</p>
<ul>
<li>A client connecting without SSL will receive the expected error (code: <code>53300</code>, message: <code>sorry, too many clients already</code>).</li>
<li>A client connecting via SSL will see a message indicating that the server does not support the SSL protocol.</li>
</ul>
<p>Default: <code>8192</code>.</p>
<h3 id="max_concurrent_creates"><a class="header" href="#max_concurrent_creates">max_concurrent_creates</a></h3>
<p>Maximum number of server connections that can be created concurrently per pool. This setting uses a semaphore to limit parallel connection creation, which significantly improves performance during cold start and burst scenarios.</p>
<p>Higher values allow faster pool warm-up but may increase load on the PostgreSQL server during connection storms. Lower values provide more gradual connection creation.</p>
<p>Default: <code>4</code>.</p>
<h3 id="tls_mode"><a class="header" href="#tls_mode">tls_mode</a></h3>
<p>The TLS mode for incoming connections. It can be one of the following:</p>
<ul>
<li><code>allow</code> - TLS connections are allowed but not required. The pg_doorman will attempt to establish a TLS connection if the client requests it.</li>
<li><code>disable</code> - TLS connections are not allowed. All connections will be established without TLS encryption.</li>
<li><code>require</code> - TLS connections are required. The pg_doorman will only accept connections that use TLS encryption.</li>
<li><code>verify-full</code> - TLS connections are required and the pg_doorman will verify the client certificate. This mode provides the highest level of security.</li>
</ul>
<p>Default: <code>"allow"</code>.</p>
<h3 id="tls_ca_cert"><a class="header" href="#tls_ca_cert">tls_ca_cert</a></h3>
<p>The file containing the CA certificate to verify the client certificate. This is required when <code>tls_mode</code> is set to <code>verify-full</code>.</p>
<p>Default: <code>None</code>.</p>
<h3 id="tls_private_key"><a class="header" href="#tls_private_key">tls_private_key</a></h3>
<p>The path to the private key file for TLS connections. This is required to enable TLS for incoming client connections. Must be used together with <code>tls_certificate</code>.</p>
<p>Default: <code>None</code>.</p>
<h3 id="tls_certificate"><a class="header" href="#tls_certificate">tls_certificate</a></h3>
<p>The path to the certificate file for TLS connections. This is required to enable TLS for incoming client connections. Must be used together with <code>tls_private_key</code>.</p>
<p>Default: <code>None</code>.</p>
<h3 id="tls_rate_limit_per_second"><a class="header" href="#tls_rate_limit_per_second">tls_rate_limit_per_second</a></h3>
<p>Limit the number of simultaneous attempts to create a TLS session.
Any value other than zero implies that there is a queue through which clients must pass in order to establish a TLS connection.
In some cases, this is necessary in order to launch an application that opens many connections at startup (the so-called "hot start").</p>
<p>Default: <code>0</code>.</p>
<h3 id="daemon_pid_file"><a class="header" href="#daemon_pid_file">daemon_pid_file</a></h3>
<p>Enabling this setting enables daemon mode. Comment this out if you want to run pg_doorman in the foreground with <code>-d</code>.</p>
<p>Default: <code>"/tmp/pg_doorman.pid"</code>.</p>
<h3 id="syslog_prog_name"><a class="header" href="#syslog_prog_name">syslog_prog_name</a></h3>
<p>When specified, pg_doorman starts sending messages to syslog (using /dev/log or /var/run/syslog).
Comment this out if you want to log to stdout.</p>
<p>Default: <code>None</code>.</p>
<h3 id="log_client_connections"><a class="header" href="#log_client_connections">log_client_connections</a></h3>
<p>Log client connections for monitoring.</p>
<p>Default: <code>true</code>.</p>
<h3 id="log_client_disconnections"><a class="header" href="#log_client_disconnections">log_client_disconnections</a></h3>
<p>Log client disconnections for monitoring.</p>
<p>Default: <code>true</code>.</p>
<h3 id="worker_threads"><a class="header" href="#worker_threads">worker_threads</a></h3>
<p>The number of worker processes (posix threads) that async serve clients, which affects the performance of pg_doorman.
The more workers there are, the faster the system works, but only up to a certain limit (cpu count).</p>
<p>This parameter also controls the number of shards in internal concurrent hash maps (DashMap).
The shard count is calculated as <code>worker_threads * 4</code> rounded up to the nearest power of 2 (minimum 4 shards).
This is important for Kubernetes deployments where CPU count detection may be incorrect, causing unnecessary overhead.</p>
<p>Default: <code>4</code>.</p>
<h3 id="worker_cpu_affinity_pinning"><a class="header" href="#worker_cpu_affinity_pinning">worker_cpu_affinity_pinning</a></h3>
<p>Automatically assign workers to different CPUs (man 3 cpu_set).</p>
<p>Default: <code>false</code>.</p>
<h3 id="tokio_global_queue_interval"><a class="header" href="#tokio_global_queue_interval">tokio_global_queue_interval</a></h3>
<p><a href="https://docs.rs/tokio/latest/tokio/runtime/struct.Builder.html#method.global_queue_interval">Tokio runtime settings</a>.
Controls how often the scheduler checks the global task queue.
Modern tokio versions handle this well by default, so this parameter is optional.</p>
<p>Default: <code>not set (uses tokio's default)</code>.</p>
<h3 id="tokio_event_interval"><a class="header" href="#tokio_event_interval">tokio_event_interval</a></h3>
<p><a href="https://docs.rs/tokio/latest/tokio/runtime/struct.Builder.html#method.event_interval">Tokio runtime settings</a>.
Controls how often the scheduler checks for external events (I/O, timers).
Modern tokio versions handle this well by default, so this parameter is optional.</p>
<p>Default: <code>not set (uses tokio's default)</code>.</p>
<h3 id="worker_stack_size"><a class="header" href="#worker_stack_size">worker_stack_size</a></h3>
<p><a href="https://docs.rs/tokio/latest/tokio/runtime/struct.Builder.html#method.thread_stack_size">Tokio runtime settings</a>.
Sets the stack size for worker threads.
Modern tokio versions handle this well by default, so this parameter is optional.</p>
<p>Default: <code>not set (uses tokio's default)</code>.</p>
<h3 id="max_blocking_threads"><a class="header" href="#max_blocking_threads">max_blocking_threads</a></h3>
<p><a href="https://docs.rs/tokio/latest/tokio/runtime/struct.Builder.html#method.max_blocking_threads">Tokio runtime settings</a>.
Sets the maximum number of threads for blocking operations.
Modern tokio versions handle this well by default, so this parameter is optional.</p>
<p>Default: <code>not set (uses tokio's default)</code>.</p>
<h3 id="connect_timeout"><a class="header" href="#connect_timeout">connect_timeout</a></h3>
<p>Connection timeout to server in milliseconds.</p>
<p>Default: <code>3000 (3 sec)</code>.</p>
<h3 id="query_wait_timeout"><a class="header" href="#query_wait_timeout">query_wait_timeout</a></h3>
<p>Maximum time to wait for a query to complete, in milliseconds.</p>
<p>Default: <code>5000 (5 sec)</code>.</p>
<h3 id="idle_timeout"><a class="header" href="#idle_timeout">idle_timeout</a></h3>
<p>Server idle timeout in milliseconds.</p>
<p>Default: <code>300000000 (5000 min)</code>.</p>
<h3 id="server_lifetime"><a class="header" href="#server_lifetime">server_lifetime</a></h3>
<p>Server lifetime in milliseconds.</p>
<p>Default: <code>300000 (5 min)</code>.</p>
<h3 id="retain_connections_time"><a class="header" href="#retain_connections_time">retain_connections_time</a></h3>
<p>Interval for checking and closing idle connections that exceed <code>idle_timeout</code> or <code>server_lifetime</code>.
The retain task runs periodically at this interval to clean up expired connections.</p>
<p>Default: <code>30000 (30 sec)</code>.</p>
<h3 id="retain_connections_max"><a class="header" href="#retain_connections_max">retain_connections_max</a></h3>
<p>Maximum number of idle connections to close per retain cycle.
When set to <code>0</code>, all idle connections that exceed <code>idle_timeout</code> or <code>server_lifetime</code> will be closed immediately.
When set to a positive value, at most that many connections will be closed per cycle across all pools.</p>
<p>This parameter controls how aggressively pg_doorman closes idle connections. With the default value of <code>3</code>,
up to 3 connections are closed per retain cycle, providing controlled cleanup. If you need faster cleanup of
expired connections, set to <code>0</code> (unlimited) to close all expired connections in each retain cycle.</p>
<p>Default: <code>3</code>.</p>
<h3 id="server_idle_check_timeout"><a class="header" href="#server_idle_check_timeout">server_idle_check_timeout</a></h3>
<p>Time after which an idle server connection should be checked before being given to a client.
This helps detect dead connections caused by PostgreSQL restart, network issues, or server-side idle timeouts.</p>
<p>When a connection has been idle in the pool longer than this timeout, pg_doorman will send a minimal query (<code>;</code>)
to verify the connection is still alive before returning it to the client. If the check fails, the connection
is discarded and a new one is obtained.</p>
<p>Set to <code>0</code> to disable the check (not recommended for production environments with potential network instability
or PostgreSQL restarts).</p>
<p>Default: <code>60s (60 seconds)</code>.</p>
<h3 id="server_round_robin"><a class="header" href="#server_round_robin">server_round_robin</a></h3>
<p>In transactional pool mode, we can choose whether the last free server backend will be used or the next one will be selected.
By default, the LRU (Least Recently Used) method is used, which has a positive impact on performance.</p>
<p>Default: <code>false</code>.</p>
<h3 id="sync_server_parameters"><a class="header" href="#sync_server_parameters">sync_server_parameters</a></h3>
<p>If enabled, we strive to restore the parameters (via query <code>SET</code>) that were set by the client (and application_name)
in transaction mode in other server backends. By default, this is disabled (false) due to performance.
If you need to know <code>application_name</code>, but don't want to experience performance issues due to constant server queries <code>SET</code>,
you can consider creating a separate pool for each application and using the <code>application_name</code> parameter in the <code>pool</code> settings.</p>
<p>Default: <code>false</code>.</p>
<h3 id="tcp_so_linger"><a class="header" href="#tcp_so_linger">tcp_so_linger</a></h3>
<p>By default, pg_doorman send <code>RST</code> instead of keeping the connection open for a long time.</p>
<p>Default: <code>0</code>.</p>
<h3 id="tcp_no_delay"><a class="header" href="#tcp_no_delay">tcp_no_delay</a></h3>
<p>TCP_NODELAY to disable Nagle's algorithm for lower latency.</p>
<p>Default: <code>true</code>.</p>
<h3 id="tcp_keepalives_count"><a class="header" href="#tcp_keepalives_count">tcp_keepalives_count</a></h3>
<p>Keepalive enabled by default and overwrite OS defaults.</p>
<p>Default: <code>5</code>.</p>
<h3 id="tcp_keepalives_idle"><a class="header" href="#tcp_keepalives_idle">tcp_keepalives_idle</a></h3>
<p>Keepalive enabled by default and overwrite OS defaults.</p>
<p>Default: <code>5</code>.</p>
<h3 id="tcp_keepalives_interval"><a class="header" href="#tcp_keepalives_interval">tcp_keepalives_interval</a></h3>
<p>TCP keepalive interval in seconds.</p>
<p>Default: <code>5</code>.</p>
<h3 id="tcp_user_timeout"><a class="header" href="#tcp_user_timeout">tcp_user_timeout</a></h3>
<p>Sets the <code>TCP_USER_TIMEOUT</code> socket option for client connections (in seconds). This option specifies
the maximum time that transmitted data may remain unacknowledged before TCP will forcibly close the
connection. This helps detect dead client connections faster than keepalive probes when the connection
is actively sending data but the remote end has become unreachable (e.g., network failure, client crash).</p>
<p>When set to a non-zero value, if data remains unacknowledged for this duration, the connection will
be terminated. This is particularly useful to avoid 15-16 minute delays caused by TCP retransmission
timeout when keepalive cannot help (e.g., during active data transmission).</p>
<p><strong>Note:</strong> This option is only supported on Linux. On other operating systems, this setting is ignored.</p>
<p>Set to <code>0</code> to disable (use OS default).</p>
<p>Default: <code>60</code>.</p>
<h3 id="unix_socket_buffer_size"><a class="header" href="#unix_socket_buffer_size">unix_socket_buffer_size</a></h3>
<p>Buffer size for read and write operations when connecting to PostgreSQL via a unix socket.</p>
<p>Default: <code>1048576</code>.</p>
<h3 id="admin_username"><a class="header" href="#admin_username">admin_username</a></h3>
<p>Access to the virtual admin database is carried out through the administrator's username and password.</p>
<p>Default: <code>"admin"</code>.</p>
<h3 id="admin_password"><a class="header" href="#admin_password">admin_password</a></h3>
<p>Access to the virtual admin database is carried out through the administrator's username and password.
It should be replaced with your secret.</p>
<p>Default: <code>"admin"</code>.</p>
<h3 id="prepared_statements"><a class="header" href="#prepared_statements">prepared_statements</a></h3>
<p>Switcher to enable/disable caching of prepared statements.</p>
<p>Default: <code>true</code>.</p>
<h3 id="prepared_statements_cache_size"><a class="header" href="#prepared_statements_cache_size">prepared_statements_cache_size</a></h3>
<p>Cache size of prepared statements at the pool level (shared across all clients connecting to the same pool).
This cache stores the mapping from query hash to rewritten prepared statement name.</p>
<p>Default: <code>8192</code>.</p>
<h3 id="client_prepared_statements_cache_size"><a class="header" href="#client_prepared_statements_cache_size">client_prepared_statements_cache_size</a></h3>
<p>Maximum number of prepared statements cached per client connection. This is a protection mechanism against
malicious or misbehaving clients that don't call <code>DEALLOCATE</code> and could cause memory exhaustion by creating
unlimited prepared statements over long-running connections.</p>
<p>When the limit is reached, the oldest entry is evicted from the client's cache. The evicted statement
can still be re-used later because the pool-level cache (<code>prepared_statements_cache_size</code>) retains the
query-to-server-name mapping.</p>
<p>Set to <code>0</code> to disable the limit (unlimited cache size, relies on client calling <code>DEALLOCATE</code>).</p>
<p>Default: <code>0 (unlimited)</code>.</p>
<h3 id="message_size_to_be_stream"><a class="header" href="#message_size_to_be_stream">message_size_to_be_stream</a></h3>
<p>Data responses from the server (message type 'D') greater than this value will be
transmitted through the proxy in small chunks (1 MB).</p>
<p>Default: <code>1048576</code>.</p>
<h3 id="max_memory_usage"><a class="header" href="#max_memory_usage">max_memory_usage</a></h3>
<p>We calculate the total amount of memory used by the internal buffers for all current queries.
If the limit is reached, the client will receive an error (256 MB).</p>
<p>Default: <code>268435456</code>.</p>
<h3 id="shutdown_timeout"><a class="header" href="#shutdown_timeout">shutdown_timeout</a></h3>
<p>With a graceful shutdown, we wait for transactions to be completed within this time limit (10 seconds).</p>
<p>Default: <code>10000</code>.</p>
<h3 id="proxy_copy_data_timeout"><a class="header" href="#proxy_copy_data_timeout">proxy_copy_data_timeout</a></h3>
<p>Maximum time to wait for data copy operations during proxying, in milliseconds.</p>
<p>Default: <code>15000 (15 sec)</code>.</p>
<h3 id="server_tls"><a class="header" href="#server_tls">server_tls</a></h3>
<p>Enable TLS for connections to the PostgreSQL server. When enabled, pg_doorman will attempt to establish TLS connections to the backend PostgreSQL servers.</p>
<p>Default: <code>false</code>.</p>
<h3 id="verify_server_certificate"><a class="header" href="#verify_server_certificate">verify_server_certificate</a></h3>
<p>Verify the PostgreSQL server's TLS certificate when connecting with TLS. This setting is only relevant when <code>server_tls</code> is enabled.</p>
<p>Default: <code>false</code>.</p>
<h3 id="hba"><a class="header" href="#hba">hba</a></h3>
<p>The list of IP addresses from which it is permitted to connect to the pg-doorman.</p>
<p>Default: <code>[]</code>.</p>
<h3 id="pg_hba"><a class="header" href="#pg_hba">pg_hba</a></h3>
<p>New-style client access control in native PostgreSQL <code>pg_hba.conf</code> format. This allows you to define fine-grained access rules similar to PostgreSQL, including per-database, per-user, address ranges, and TLS requirements.</p>
<p>You can specify <code>general.pg_hba</code> in three ways:</p>
<ul>
<li>As a multi-line string with the contents of a <code>pg_hba.conf</code> file</li>
<li>As an object with <code>path</code> that points to a file on disk</li>
<li>As an object with <code>content</code> containing the rules as a string</li>
</ul>
<p>Examples:</p>
<pre><code class="language-toml">[general]
# Inline content (triple-quoted TOML string)
pg_hba = """
# type   database  user   address         method
host     all       all    10.0.0.0/8      md5
hostssl  all       all    0.0.0.0/0       scram-sha-256
hostnossl all      all    192.168.1.0/24  trust
"""

# Or load from file
# pg_hba = { path = "./pg_hba.conf" }

# Or embed as a single-line string
# pg_hba = { content = "host all all 127.0.0.1/32 trust" }
</code></pre>
<p>Supported fields and methods:</p>
<ul>
<li>Connection types: <code>local</code>, <code>host</code>, <code>hostssl</code>, <code>hostnossl</code> (TLS-aware matching is honored)</li>
<li>Database matcher: a name or <code>all</code></li>
<li>User matcher: a name or <code>all</code></li>
<li>Address: CIDR form like <code>1.2.3.4/32</code> or <code>::1/128</code> (required for non-<code>local</code> rules)</li>
<li>Methods: <code>trust</code>, <code>md5</code>, <code>scram-sha-256</code> (unknown methods are parsed but treated as not-allowed by the checker)</li>
</ul>
<p>Precedence and compatibility:</p>
<ul>
<li><code>general.pg_hba</code> supersedes the legacy <code>general.hba</code> list. You cannot set both at the same time; configuration validation will reject this combination.</li>
<li>Rules are evaluated in order; the first matching rule decides the outcome.</li>
</ul>
<p>Behavior of method = trust:</p>
<ul>
<li>When a matching rule has <code>trust</code>, PgDoorman will accept the connection without requesting a password. This mirrors PostgreSQL behavior.</li>
<li>Specifically, if <code>trust</code> matches, PgDoorman will skip password verification even if the user has an <code>md5</code> or <code>scram-sha-256</code> password stored. This affects both MD5 and SCRAM flows.</li>
<li>TLS constraints from the rule are respected: <code>hostssl</code> requires TLS, <code>hostnossl</code> forbids TLS.</li>
</ul>
<p>Admin console access:</p>
<ul>
<li><code>general.pg_hba</code> rules apply to the special admin database <code>pgdoorman</code> as well.</li>
<li>This means you can allow admin access with the <code>trust</code> method when a matching rule is present, for example:
<pre><code>host  pgdoorman  admin  127.0.0.1/32  trust
</code></pre>
</li>
</ul>
<p>Notes and limitations:</p>
<ul>
<li>Only a minimal subset of <code>pg_hba.conf</code> is supported that is sufficient for most proxy use-cases (type, database, user, address, method). Additional options (like <code>clientcert</code>) are currently ignored.</li>
<li>For authentication methods other than <code>trust</code>, PgDoorman performs the corresponding challenge/response with the client.</li>
<li>For Talos/JWT/PAM flows configured at the pool/user level, <code>trust</code> still bypasses the client password prompt; however, those modes may be used when <code>trust</code> does not match.</li>
</ul>
<h3 id="pooler_check_query"><a class="header" href="#pooler_check_query">pooler_check_query</a></h3>
<p>This query will not be sent to the server if it is run as a SimpleQuery.
It can be used to check the connection at the application level.</p>
<p>Default: <code>";"</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pool-settings"><a class="header" href="#pool-settings">Pool Settings</a></h2>
<p>Each record in the pool is the name of the virtual database that the pg-doorman client can connect to.</p>
<pre><code class="language-toml">[pools.exampledb] # Declaring the 'exampledb' database
</code></pre>
<h3 id="server_host"><a class="header" href="#server_host">server_host</a></h3>
<p>The directory with unix sockets or the IPv4 address of the PostgreSQL server that serves this pool.</p>
<p>Example: <code>"/var/run/postgresql"</code> or <code>"127.0.0.1"</code>.</p>
<p>Default: <code>"127.0.0.1"</code>.</p>
<h3 id="server_port"><a class="header" href="#server_port">server_port</a></h3>
<p>The port through which PostgreSQL server accepts incoming connections.</p>
<p>Default: <code>5432</code>.</p>
<h3 id="server_database"><a class="header" href="#server_database">server_database</a></h3>
<p>Optional parameter that determines which database should be connected to on the PostgreSQL server.</p>
<h3 id="application_name"><a class="header" href="#application_name">application_name</a></h3>
<p>Parameter application_name, is sent to the server when opening a connection with PostgreSQL. It may be useful with the sync_server_parameters = false setting.</p>
<h3 id="connect_timeout-1"><a class="header" href="#connect_timeout-1">connect_timeout</a></h3>
<p>Maximum time to allow for establishing a new server connection for this pool, in milliseconds. If not specified, the global connect_timeout setting is used.</p>
<p>Default: <code>None (uses global setting)</code>.</p>
<h3 id="idle_timeout-1"><a class="header" href="#idle_timeout-1">idle_timeout</a></h3>
<p>Close idle connections in this pool that have been opened for longer than this value, in milliseconds. If not specified, the global idle_timeout setting is used.</p>
<p>Default: <code>None (uses global setting)</code>.</p>
<h3 id="server_lifetime-1"><a class="header" href="#server_lifetime-1">server_lifetime</a></h3>
<p>Close server connections in this pool that have been opened for longer than this value, in milliseconds. Only applied to idle connections. If not specified, the global server_lifetime setting is used.</p>
<p>Default: <code>None (uses global setting)</code>.</p>
<h3 id="pool_mode"><a class="header" href="#pool_mode">pool_mode</a></h3>
<ul>
<li><code>session</code> â€” Server is released back to pool after client disconnects.</li>
<li><code>transaction</code> â€” Server is released back to pool after transaction finishes.</li>
</ul>
<p>Default: <code>"transaction"</code>.</p>
<h3 id="log_client_parameter_status_changes"><a class="header" href="#log_client_parameter_status_changes">log_client_parameter_status_changes</a></h3>
<p>Log information about any SET command in the log.</p>
<p>Default: <code>false</code>.</p>
<h3 id="cleanup_server_connections"><a class="header" href="#cleanup_server_connections">cleanup_server_connections</a></h3>
<p>When enabled, the pool will automatically clean up server connections that are no longer needed. This helps manage resources efficiently by closing idle connections.</p>
<p>Default: <code>true</code>.</p>
<h2 id="pool-users-settings"><a class="header" href="#pool-users-settings">Pool Users Settings</a></h2>
<pre><code class="language-toml">[pools.exampledb.users.0]
username = "exampledb-user-0" # A virtual user who can connect to this virtual database.
</code></pre>
<h3 id="username"><a class="header" href="#username">username</a></h3>
<p>A virtual username who can connect to this virtual database (pool).</p>
<h3 id="password"><a class="header" href="#password">password</a></h3>
<p>The password for the virtual pool user.
Password can be specified in <code>MD5</code>, <code>SCRAM-SHA-256</code>, or <code>JWT</code> format.
Also, you can create a mirror list of users using secrets from the PostgreSQL instance: <code>select usename, passwd from pg_shadow</code>.</p>
<h3 id="auth_pam_service"><a class="header" href="#auth_pam_service">auth_pam_service</a></h3>
<p>The pam-service that is responsible for client authorization. In this case, pg_doorman will ignore the <code>password</code> value.</p>
<h3 id="server_username"><a class="header" href="#server_username">server_username</a></h3>
<p>The real PostgreSQL username used to connect to the database server.</p>
<p>By default, PgDoorman uses the same <code>username</code> for both client authentication and server connections. However, if the client <code>password</code> is an MD5 or SCRAM hash (which is the typical setup), PostgreSQL will <strong>reject the connection</strong> because it expects a plaintext password, not a hash.</p>
<p>To fix this, set <code>server_username</code> and <code>server_password</code> to the actual PostgreSQL credentials. Both must be specified together.</p>
<h3 id="server_password"><a class="header" href="#server_password">server_password</a></h3>
<p>The plaintext password for the PostgreSQL server user specified in <code>server_username</code>.</p>
<p>This is needed because PgDoorman stores client passwords as MD5/SCRAM hashes for client authentication, but PostgreSQL requires a plaintext password during server-side authentication.</p>
<h3 id="pool_size"><a class="header" href="#pool_size">pool_size</a></h3>
<p>The maximum number of simultaneous connections to the PostgreSQL server available for this pool and user.</p>
<p>Default: <code>40</code>.</p>
<h3 id="min_pool_size"><a class="header" href="#min_pool_size">min_pool_size</a></h3>
<p>The minimum number of connections to maintain in the pool for this user. This helps with performance by keeping connections ready. If specified, it must be less than or equal to pool_size.</p>
<p>Default: <code>None</code>.</p>
<h3 id="server_lifetime-2"><a class="header" href="#server_lifetime-2">server_lifetime</a></h3>
<p>Close server connections for this user that have been opened for longer than this value, in milliseconds. Only applied to idle connections. If not specified, the pool's server_lifetime setting is used.</p>
<p>Default: <code>None (uses pool setting)</code>.</p>
<div id="admonition-common-setup-issue" class="admonition admonish-warning" role="note" aria-labelledby="admonition-common-setup-issue-title">
<div class="admonition-title">
<div id="admonition-common-setup-issue-title">
<p>Common Setup Issue</p>
</div>
<a class="admonition-anchor-link" href="reference/pool.html#admonition-common-setup-issue"></a>
</div>
<div>
<p>If you see authentication errors when PgDoorman tries to connect to PostgreSQL, the most likely cause is that <code>server_username</code> and <code>server_password</code> are not set. Without these, PgDoorman tries to authenticate to PostgreSQL using the MD5/SCRAM hash from the <code>password</code> field, which PostgreSQL rejects.</p>
<p><strong>Solution:</strong> Set both <code>server_username</code> and <code>server_password</code> to the actual PostgreSQL credentials:</p>
<pre><code class="language-yaml">users:
  - username: "app_user"
    password: "md5..."                # hash for client authentication
    server_username: "app_user"       # real PostgreSQL username
    server_password: "plaintext_pwd"  # real PostgreSQL password
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prometheus-settings"><a class="header" href="#prometheus-settings">Prometheus Settings</a></h1>
<p>pg_doorman includes a Prometheus metrics exporter that provides detailed insights into the performance and behavior of your connection pools. This document describes how to enable and use the Prometheus metrics exporter, as well as the available metrics.</p>
<h2 id="enabling-prometheus-metrics"><a class="header" href="#enabling-prometheus-metrics">Enabling Prometheus Metrics</a></h2>
<p>To enable the Prometheus metrics exporter, add the following to your configuration file:</p>
<pre><code class="language-yaml">prometheus:
  enabled: true
  host: "0.0.0.0"  # The host on which the metrics server will listen
  port: 9127       # The port on which the metrics server will listen
</code></pre>
<h3 id="configuration-options-1"><a class="header" href="#configuration-options-1">Configuration Options</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>enabled</code></td><td>Enable or disable the Prometheus metrics exporter.</td><td><code>false</code></td></tr>
<tr><td><code>host</code></td><td>The host on which the Prometheus metrics exporter will listen.</td><td><code>"0.0.0.0"</code></td></tr>
<tr><td><code>port</code></td><td>The port on which the Prometheus metrics exporter will listen.</td><td><code>9127</code></td></tr>
</tbody></table>
</div>
<h2 id="configuring-prometheus"><a class="header" href="#configuring-prometheus">Configuring Prometheus</a></h2>
<p>Add the following job to your Prometheus configuration to scrape metrics from pg_doorman:</p>
<pre><code class="language-yaml">scrape_configs:
  - job_name: 'pg_doorman'
    static_configs:
      - targets: ['&lt;pg_doorman_host&gt;:9127']
</code></pre>
<p>Replace <code>&lt;pg_doorman_host&gt;</code> with the hostname or IP address of your pg_doorman instance.</p>
<h2 id="available-metrics"><a class="header" href="#available-metrics">Available Metrics</a></h2>
<p>pg_doorman exposes the following metrics:</p>
<h3 id="system-metrics"><a class="header" href="#system-metrics">System Metrics</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Metric</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pg_doorman_total_memory</code></td><td>Total memory allocated to the pg_doorman process in bytes. Monitors the memory footprint of the application.</td></tr>
</tbody></table>
</div>
<h3 id="connection-metrics"><a class="header" href="#connection-metrics">Connection Metrics</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Metric</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pg_doorman_connection_count</code></td><td>Counter of new connections by type handled by pg_doorman. Types include: 'plain' (unencrypted connections), 'tls' (encrypted connections), 'cancel' (connection cancellation requests), and 'total' (sum of all connections).</td></tr>
</tbody></table>
</div>
<h3 id="socket-metrics-linux-only"><a class="header" href="#socket-metrics-linux-only">Socket Metrics (Linux only)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Metric</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pg_doorman_sockets</code></td><td>Counter of sockets used by pg_doorman by socket type. Types include: 'tcp' (IPv4 TCP sockets), 'tcp6' (IPv6 TCP sockets), 'unix' (Unix domain sockets), and 'unknown' (sockets of unrecognized type). Only available on Linux systems.</td></tr>
</tbody></table>
</div>
<h3 id="pool-metrics"><a class="header" href="#pool-metrics">Pool Metrics</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Metric</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pg_doorman_pools_clients</code></td><td>Number of clients in connection pools by status, user, and database. Status values include: 'idle' (connected but not executing queries), 'waiting' (waiting for a server connection), and 'active' (currently executing queries). Helps monitor connection pool utilization and client distribution.</td></tr>
<tr><td><code>pg_doorman_pools_servers</code></td><td>Number of servers in connection pools by status, user, and database. Status values include: 'active' (actively serving clients) and 'idle' (available for new connections). Helps monitor server availability and load distribution.</td></tr>
<tr><td><code>pg_doorman_pools_bytes</code></td><td>Total bytes transferred through connection pools by direction, user, and database. Direction values include: 'received' (bytes received from clients) and 'sent' (bytes sent to clients). Useful for monitoring network traffic and identifying high-volume connections.</td></tr>
</tbody></table>
</div>
<h3 id="query-and-transaction-metrics"><a class="header" href="#query-and-transaction-metrics">Query and Transaction Metrics</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Metric</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pg_doorman_pools_queries_percentile</code></td><td>Query execution time percentiles by user and database. Percentile values include: '99', '95', '90', and '50' (median). Values are in milliseconds. Helps identify slow queries and performance trends across different users and databases.</td></tr>
<tr><td><code>pg_doorman_pools_transactions_percentile</code></td><td>Transaction execution time percentiles by user and database. Percentile values include: '99', '95', '90', and '50' (median). Values are in milliseconds. Helps monitor transaction performance and identify long-running transactions that might impact database performance.</td></tr>
<tr><td><code>pg_doorman_pools_transactions_count</code></td><td>Counter of transactions executed in connection pools by user and database. Helps track transaction volume and identify users or databases with high transaction rates.</td></tr>
<tr><td><code>pg_doorman_pools_transactions_total_time</code></td><td>Total time spent executing transactions in connection pools by user and database. Values are in milliseconds. Helps monitor overall transaction performance and identify users or databases with high transaction execution times.</td></tr>
<tr><td><code>pg_doorman_pools_queries_count</code></td><td>Counter of queries executed in connection pools by user and database. Helps track query volume and identify users or databases with high query rates.</td></tr>
<tr><td><code>pg_doorman_pools_queries_total_time</code></td><td>Total time spent executing queries in connection pools by user and database. Values are in milliseconds. Helps monitor overall query performance and identify users or databases with high query execution times.</td></tr>
<tr><td><code>pg_doorman_pools_avg_wait_time</code></td><td>Average wait time for clients in connection pools by user and database. Values are in milliseconds. Helps monitor client wait times and identify potential bottlenecks.</td></tr>
</tbody></table>
</div>
<h3 id="server-metrics"><a class="header" href="#server-metrics">Server Metrics</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Metric</th><th>Description</th></tr></thead><tbody>
<tr><td><code>pg_doorman_servers_prepared_hits</code></td><td>Counter of prepared statement hits in databases backends by user and database. Helps track the effectiveness of prepared statements in reducing query parsing overhead.</td></tr>
<tr><td><code>pg_doorman_servers_prepared_misses</code></td><td>Counter of prepared statement misses in databases backends by user and database. Helps identify queries that could benefit from being prepared to improve performance.</td></tr>
</tbody></table>
</div>
<h2 id="grafana-dashboard"><a class="header" href="#grafana-dashboard">Grafana Dashboard</a></h2>
<p>You can create a Grafana dashboard to visualize these metrics. Here's a simple example of panels you might want to include:</p>
<ol>
<li>Connection counts by type</li>
<li>Memory usage over time</li>
<li>Client and server counts by pool</li>
<li>Query and transaction performance percentiles</li>
<li>Network traffic by pool</li>
</ol>
<h2 id="example-queries"><a class="header" href="#example-queries">Example Queries</a></h2>
<p>Here are some example Prometheus queries that you might find useful:</p>
<h3 id="connection-rate"><a class="header" href="#connection-rate">Connection Rate</a></h3>
<pre><code>rate(pg_doorman_connection_count{type="total"}[5m])
</code></pre>
<h3 id="pool-utilization"><a class="header" href="#pool-utilization">Pool Utilization</a></h3>
<pre><code>sum by (database) (pg_doorman_pools_clients{status="active"}) / sum by (database) (pg_doorman_pools_servers{status="active"} + pg_doorman_pools_servers{status="idle"})
</code></pre>
<h3 id="slow-queries"><a class="header" href="#slow-queries">Slow Queries</a></h3>
<pre><code>pg_doorman_pools_queries_percentile{percentile="99"}
</code></pre>
<h3 id="client-wait-time"><a class="header" href="#client-wait-time">Client Wait Time</a></h3>
<pre><code>pg_doorman_pools_avg_wait_time
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance-benchmarks"><a class="header" href="#performance-benchmarks">Performance Benchmarks</a></h1>
<h2 id="automated-benchmark-results"><a class="header" href="#automated-benchmark-results">Automated Benchmark Results</a></h2>
<p>Last updated: 2026-02-20 21:07 UTC</p>
<p>These benchmarks are automatically generated by the CI pipeline using <code>pgbench</code>.</p>
<h3 id="test-environment"><a class="header" href="#test-environment">Test Environment</a></h3>
<ul>
<li><strong>Pool size</strong>: 40 connections</li>
<li><strong>Test duration</strong>: 30 seconds per test</li>
<li><strong>Instance</strong>: AWS Fargate (16 vCPU, 32 GB RAM)</li>
<li><strong>Workers</strong>: pg_doorman: 12, odyssey: 12</li>
<li><strong>pgbench jobs</strong>: 4 (global override)</li>
<li><strong>Started</strong>: 2026-02-20 19:44:16 UTC</li>
<li><strong>Finished</strong>: 2026-02-20 21:07:31 UTC</li>
<li><strong>Total duration</strong>: 1h 23m 14s</li>
</ul>
<h3 id="legend"><a class="header" href="#legend">Legend</a></h3>
<ul>
<li><strong>+N%</strong>: pg_doorman is N% faster than competitor (e.g., +10% means pg_doorman is 10% faster)</li>
<li><strong>-N%</strong>: pg_doorman is N% slower than competitor (e.g., -10% means pg_doorman is 10% slower)</li>
<li><strong>â‰ˆ0%</strong>: Equal performance (difference less than 3%)</li>
<li><strong>âˆž</strong>: Competitor failed (0 TPS), pg_doorman wins</li>
<li><strong>N/A</strong>: Test not supported by this pooler</li>
<li><strong>-</strong>: Test not executed</li>
</ul>
<hr />
<h2 id="simple-protocol"><a class="header" href="#simple-protocol">Simple Protocol</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Test</th><th>vs pgbouncer</th><th>vs odyssey</th></tr></thead><tbody>
<tr><td>1 client</td><td>-7%</td><td>-9%</td></tr>
<tr><td>40 clients</td><td>+40%</td><td>-39%</td></tr>
<tr><td>120 clients</td><td>x3.0</td><td>-6%</td></tr>
<tr><td>500 clients</td><td>x2.8</td><td>â‰ˆ0%</td></tr>
<tr><td>10,000 clients</td><td>x2.8</td><td>+19%</td></tr>
<tr><td>1 client + Reconnect</td><td>â‰ˆ0%</td><td>x4.3</td></tr>
<tr><td>40 clients + Reconnect</td><td>+22%</td><td>x2.5</td></tr>
<tr><td>120 clients + Reconnect</td><td>+22%</td><td>x2.4</td></tr>
<tr><td>500 clients + Reconnect</td><td>+23%</td><td>x2.1</td></tr>
<tr><td>10,000 clients + Reconnect</td><td>+68%</td><td>x2.4</td></tr>
<tr><td>1 client + SSL</td><td>-6%</td><td>-9%</td></tr>
<tr><td>40 clients + SSL</td><td>+73%</td><td>-28%</td></tr>
<tr><td>120 clients + SSL</td><td>x3.4</td><td>â‰ˆ0%</td></tr>
<tr><td>500 clients + SSL</td><td>x3.2</td><td>+4%</td></tr>
<tr><td>10,000 clients + SSL</td><td>x3.3</td><td>+18%</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="extended-protocol"><a class="header" href="#extended-protocol">Extended Protocol</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Test</th><th>vs pgbouncer</th><th>vs odyssey</th></tr></thead><tbody>
<tr><td>1 client</td><td>+5%</td><td>+42%</td></tr>
<tr><td>40 clients</td><td>+52%</td><td>-7%</td></tr>
<tr><td>120 clients</td><td>x3.1</td><td>+46%</td></tr>
<tr><td>500 clients</td><td>x2.9</td><td>+57%</td></tr>
<tr><td>10,000 clients</td><td>x2.9</td><td>+82%</td></tr>
<tr><td>1 client + Reconnect</td><td>â‰ˆ0%</td><td>x113.6</td></tr>
<tr><td>40 clients + Reconnect</td><td>+22%</td><td>x3.3</td></tr>
<tr><td>120 clients + Reconnect</td><td>+23%</td><td>x2.3</td></tr>
<tr><td>500 clients + Reconnect</td><td>+22%</td><td>+94%</td></tr>
<tr><td>10,000 clients + Reconnect</td><td>+66%</td><td>+98%</td></tr>
<tr><td>1 client + SSL</td><td>+5%</td><td>+40%</td></tr>
<tr><td>40 clients + SSL</td><td>+74%</td><td>+3%</td></tr>
<tr><td>120 clients + SSL</td><td>x3.5</td><td>+46%</td></tr>
<tr><td>500 clients + SSL</td><td>x3.4</td><td>+57%</td></tr>
<tr><td>10,000 clients + SSL</td><td>x3.5</td><td>+79%</td></tr>
<tr><td>1 client + SSL + Reconnect</td><td>+6%</td><td>+10%</td></tr>
<tr><td>40 clients + SSL + Reconnect</td><td>+92%</td><td>â‰ˆ0%</td></tr>
<tr><td>120 clients + SSL + Reconnect</td><td>+94%</td><td>â‰ˆ0%</td></tr>
<tr><td>500 clients + SSL + Reconnect</td><td>+94%</td><td>â‰ˆ0%</td></tr>
<tr><td>10,000 clients + SSL + Reconnect</td><td>+89%</td><td>â‰ˆ0%</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="prepared-protocol"><a class="header" href="#prepared-protocol">Prepared Protocol</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Test</th><th>vs pgbouncer</th><th>vs odyssey</th></tr></thead><tbody>
<tr><td>1 client</td><td>-9%</td><td>-12%</td></tr>
<tr><td>40 clients</td><td>+71%</td><td>-42%</td></tr>
<tr><td>120 clients</td><td>x3.7</td><td>-8%</td></tr>
<tr><td>500 clients</td><td>x3.5</td><td>â‰ˆ0%</td></tr>
<tr><td>10,000 clients</td><td>x3.4</td><td>+22%</td></tr>
<tr><td>1 client + Reconnect</td><td>â‰ˆ0%</td><td>+52%</td></tr>
<tr><td>40 clients + Reconnect</td><td>â‰ˆ0%</td><td>âˆž</td></tr>
<tr><td>120 clients + Reconnect</td><td>+5%</td><td>âˆž</td></tr>
<tr><td>500 clients + Reconnect</td><td>+7%</td><td>âˆž</td></tr>
<tr><td>10,000 clients + Reconnect</td><td>+29%</td><td>âˆž</td></tr>
<tr><td>1 client + SSL</td><td>-7%</td><td>-10%</td></tr>
<tr><td>40 clients + SSL</td><td>x2.0</td><td>-32%</td></tr>
<tr><td>120 clients + SSL</td><td>x3.9</td><td>-6%</td></tr>
<tr><td>500 clients + SSL</td><td>x3.9</td><td>+3%</td></tr>
<tr><td>10,000 clients + SSL</td><td>x4.0</td><td>+19%</td></tr>
</tbody></table>
</div>
<hr />
<h3 id="notes"><a class="header" href="#notes">Notes</a></h3>
<ul>
<li>Odyssey has poor support for extended query protocol in transaction pooling mode, resulting in significantly lower performance compared to pg_doorman and pgbouncer</li>
<li><strong>Important</strong>: The values shown are <strong>relative performance ratios</strong>, not absolute TPS numbers. While absolute TPS values may vary depending on hardware and system load, the relative ratios between poolers should remain consistent when tests are run sequentially in a short timeframe (30 seconds each). This allows for fair comparison across different connection poolers under identical conditions</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="changelog"><a class="header" href="#changelog">Changelog</a></h1>
<h3 id="324-feb-20-2026"><a class="header" href="#324-feb-20-2026">3.2.4 <small>Feb 20, 2026</small></a></h3>
<p><strong>New Features:</strong></p>
<ul>
<li>
<p><strong>Annotated config generation</strong>: The <code>generate</code> command now produces well-documented configuration files with inline comments for every parameter by default. Previously it only did plain serde serialization without any documentation.</p>
</li>
<li>
<p><strong><code>--reference</code> flag</strong>: Generates a complete reference config with example values without requiring a PostgreSQL connection. The root <code>pg_doorman.toml</code> and <code>pg_doorman.yaml</code> are now auto-generated from this flag, ensuring they always stay in sync with the codebase.</p>
</li>
<li>
<p><strong><code>--format</code> (<code>-f</code>) flag</strong>: Explicitly choose output format (<code>yaml</code> or <code>toml</code>). Default output format changed from TOML to YAML. When <code>--output</code> is specified, format is auto-detected from file extension; <code>--format</code> overrides auto-detection.</p>
</li>
<li>
<p><strong><code>--russian-comments</code> (<code>--ru</code>) flag</strong>: Generates comments in Russian for quick start guide. All ~100+ comment strings are translated to clear, simple Russian.</p>
</li>
<li>
<p><strong><code>--no-comments</code> flag</strong>: Disables inline comments for minimal config output (plain serde serialization, the old default behavior).</p>
</li>
<li>
<p><strong>Server authentication documentation</strong>: Prominently documents the <code>server_username</code>/<code>server_password</code> requirement in generated configs, README, reference docs, and troubleshooting guide â€” the #1 issue for new users who get authentication errors because PostgreSQL rejects MD5/SCRAM hashes as passwords.</p>
</li>
</ul>
<p><strong>Testing:</strong></p>
<ul>
<li>
<p><strong>Config field coverage guarantee</strong>: New test parses config struct source files (<code>general.rs</code>, <code>pool.rs</code>, <code>user.rs</code>, etc.) at compile time and verifies every <code>pub</code> field appears in annotated output. If someone adds a new config parameter but forgets to add it to <code>annotated.rs</code>, CI will fail with a clear message listing the missing fields.</p>
</li>
<li>
<p><strong>BDD tests for generate command</strong>: End-to-end tests that generate TOML and YAML configs, start pg_doorman with them, and verify client connectivity.</p>
</li>
</ul>
<p><strong>Bug Fixes:</strong></p>
<ul>
<li>
<p><strong>Fixed protocol desynchronization on prepared statement cache eviction in async mode</strong>: When asyncpg/SQLAlchemy uses <code>Flush</code> (instead of <code>Sync</code>) for pipelined <code>Parse+Describe</code> batches and the prepared statement LRU cache is full, eviction sends <code>Close+Sync</code> to the server. In async mode, <code>recv()</code> was exiting immediately when <code>expected_responses==0</code>, leaving <code>CloseComplete</code> and <code>ReadyForQuery</code> unread in the TCP buffer. The next <code>recv()</code> call would then read these stale messages instead of the expected response, causing protocol desynchronization. Fixed by temporarily disabling async mode during eviction so that <code>recv()</code> waits for <code>ReadyForQuery</code> as the natural loop terminator.</p>
</li>
<li>
<p><strong>Fixed generated config startup failure</strong>: <code>syslog_prog_name</code> and <code>daemon_pid_file</code> are now commented out by default in generated configs. Previously they were uncommented, causing pg_doorman to fail when started in foreground mode or when syslog was unavailable.</p>
</li>
<li>
<p><strong>Fixed Go test goroutine leak</strong>: <code>TestLibPQPrepared</code> now uses <code>sync.WaitGroup</code> to wait for all goroutines before test exit, fixing sporadic panics caused by logging after test completion.</p>
</li>
<li>
<p><strong>Fixed protocol violation on flush timeout â€” client now receives ErrorResponse</strong>: When the 5-second flush timeout fires (server TCP write blocks because the backend is overloaded or unreachable), the <code>FlushTimeout</code> error was propagating via <code>?</code> through <code>handle_sync_flush</code> â†’ transaction loop â†’ <code>handle()</code> without sending any PostgreSQL protocol message to the client. The TCP connection was simply dropped, causing drivers like Npgsql to report "protocol violation" due to unexpected EOF. Now pg_doorman sends a proper <code>ErrorResponse</code> with SQLSTATE <code>58006</code> and message containing "pooler is shut down now" before closing the connection, allowing client drivers to detect the error and reconnect gracefully.</p>
</li>
</ul>
<h3 id="323-feb-10-2026"><a class="header" href="#323-feb-10-2026">3.2.3 <small>Feb 10, 2026</small></a></h3>
<p><strong>Improvements:</strong></p>
<ul>
<li><strong>Jitter for <code>server_lifetime</code> (Â±20%)</strong>: Connection lifetimes now have a random Â±20% jitter applied to prevent mass disconnections from PostgreSQL. When pg_doorman is under heavy load, it creates many connections simultaneously, which previously caused them all to expire at the same time, creating spikes of connection closures. Now each connection gets an individual lifetime calculated as <code>base_lifetime Â± random(20%)</code>. For example, with <code>server_lifetime: 300000</code> (5 minutes), actual lifetimes range from 240s to 360s, spreading connection closures evenly over time.</li>
</ul>
<h3 id="322-feb-9-2026"><a class="header" href="#322-feb-9-2026">3.2.2 <small>Feb 9, 2026</small></a></h3>
<p><strong>New Features:</strong></p>
<ul>
<li>
<p><strong>Configuration test mode (<code>-t</code> / <code>--test-config</code>)</strong>: Added nginx-style configuration validation flag. Running <code>pg_doorman -t</code> or <code>pg_doorman --test-config</code> will parse and validate the configuration file, report success or errors, and exit without starting the server. Useful for CI/CD pipelines and pre-deployment configuration checks.</p>
</li>
<li>
<p><strong>Configuration validation before binary upgrade</strong>: When receiving SIGINT for graceful shutdown/binary upgrade, the server now validates the new binary's configuration using <code>-t</code> flag before proceeding. If the configuration test fails, the shutdown is cancelled and critical error messages are logged to alert the operator. This prevents accidental downtime from deploying a binary with invalid configuration.</p>
</li>
<li>
<p><strong>New <code>retain_connections_max</code> configuration parameter</strong>: Controls the maximum number of idle connections to close per retain cycle. When set to <code>0</code>, all idle connections that exceed <code>idle_timeout</code> or <code>server_lifetime</code> are closed immediately. Default is <code>3</code>, providing controlled cleanup while preventing connection buildup. Previously, only 1 connection was closed per cycle, which could lead to slow connection cleanup when many connections became idle simultaneously. Connection closures are now logged for better observability.</p>
</li>
<li>
<p><strong>Oldest-first connection closure</strong>: When <code>retain_connections_max &gt; 0</code>, connections are now closed in order of age (oldest first) rather than in queue order. This ensures that the oldest connections are always prioritized for closure, providing more predictable connection rotation behavior.</p>
</li>
<li>
<p><strong>New <code>server_idle_check_timeout</code> configuration parameter</strong>: Time after which an idle server connection should be checked before being given to a client (default: 30s). This helps detect dead connections caused by PostgreSQL restart, network issues, or server-side idle timeouts. When a connection has been idle longer than this timeout, pg_doorman sends a minimal query (<code>;</code>) to verify the connection is alive before returning it to the client. Set to <code>0</code> to disable.</p>
</li>
<li>
<p><strong>New <code>tcp_user_timeout</code> configuration parameter</strong>: Sets the <code>TCP_USER_TIMEOUT</code> socket option for client connections (in seconds). This helps detect dead client connections faster than keepalive probes when the connection is actively sending data but the remote end has become unreachable. Prevents 15-16 minute delays caused by TCP retransmission timeout. Only supported on Linux. Default is <code>60</code> seconds. Set to <code>0</code> to disable.</p>
</li>
<li>
<p><strong>Removed <code>wait_rollback</code> mechanism</strong>: The pooler no longer attempts to automatically wait for ROLLBACK from clients when a transaction enters an aborted state. This complex mechanism was causing protocol desynchronization issues with async clients and extended query protocol. Server connections in aborted transactions are now simply returned to the pool and cleaned up normally via ROLLBACK during checkin.</p>
</li>
<li>
<p><strong>Removed savepoint tracking</strong>: Removed the <code>use_savepoint</code> flag and related logic that was tracking SAVEPOINT usage. The pooler now treats savepoints as regular PostgreSQL commands without special handling.</p>
</li>
</ul>
<p><strong>Bug Fixes:</strong></p>
<ul>
<li><strong>Fixed protocol desynchronization in async mode with simple prepared statements</strong>: When <code>prepared_statements</code> was disabled but clients used extended query protocol (Parse, Bind, Describe, Execute, Flush), the pooler wasn't tracking batch operations, causing <code>expected_responses</code> to be calculated as 0. This led to the pooler exiting the response loop immediately without waiting for server responses (ParseComplete, BindComplete, etc.). Now batch operations are tracked regardless of the <code>prepared_statements</code> setting.</li>
</ul>
<p><strong>Performance:</strong></p>
<ul>
<li><strong>Removed timeout-based waiting in async protocol</strong>: The pooler now tracks expected responses based on batch operations (Parse, Bind, Execute, etc.) and exits immediately when all responses are received. This eliminates unnecessary latency in pipeline/async workloads.</li>
</ul>
<h3 id="318-jan-31-2026"><a class="header" href="#318-jan-31-2026">3.1.8 <small>Jan 31, 2026</small></a></h3>
<p><strong>Bug Fixes:</strong></p>
<ul>
<li>
<p><strong>Fixed ParseComplete desynchronization in pipeline on errors</strong>: Fixed a protocol desynchronization issue (especially noticeable in .NET Npgsql driver) where synthetic <code>ParseComplete</code> messages were not being inserted if an error occurred during a pipelined batch. When the pooler caches a prepared statement and skips sending <code>Parse</code> to the server, it must still provide a <code>ParseComplete</code> to the client. If an error occurs before subsequent commands are processed, the server skips them, and the pooler now ensures all missing synthetic <code>ParseComplete</code> messages are inserted into the response stream upon receiving an <code>ErrorResponse</code> or <code>ReadyForQuery</code>.</p>
</li>
<li>
<p><strong>Fixed incorrect <code>use_savepoint</code> state persistence</strong>: Fixed a bug where the <code>use_savepoint</code> flag (which disables automatic rollback on connection return if a savepoint was used) was not reset after a transaction ended.</p>
</li>
</ul>
<h3 id="317-jan-28-2026"><a class="header" href="#317-jan-28-2026">3.1.7 <small>Jan 28, 2026</small></a></h3>
<p><strong>Memory Optimization:</strong></p>
<ul>
<li>
<p><strong>DEALLOCATE now clears client prepared statements cache</strong>: When a client sends <code>DEALLOCATE &lt;name&gt;</code> or <code>DEALLOCATE ALL</code> via simple query protocol, the pooler now properly clears the corresponding entries from the client's internal prepared statements cache. Previously, synthetic OK responses were sent but the client cache was not cleared, causing memory to grow indefinitely for long-running connections using many unique prepared statements. This fix allows memory to be reclaimed when clients properly deallocate their statements.</p>
</li>
<li>
<p><strong>New <code>client_prepared_statements_cache_size</code> configuration parameter</strong>: Added protection against malicious or misbehaving clients that don't call <code>DEALLOCATE</code> and could exhaust server memory by creating unlimited prepared statements. When the per-client cache limit is reached, the oldest entry is evicted automatically. Set to <code>0</code> for unlimited (default, relies on client calling <code>DEALLOCATE</code>). Example: <code>client_prepared_statements_cache_size: 1024</code> limits each client to 1024 cached prepared statements.</p>
</li>
</ul>
<h3 id="316-jan-27-2026"><a class="header" href="#316-jan-27-2026">3.1.6 <small>Jan 27, 2026</small></a></h3>
<p><strong>Bug Fixes:</strong></p>
<ul>
<li>
<p><strong>Fixed incorrect timing statistics (xact_time, wait_time, percentiles)</strong>: The statistics module was using <code>recent()</code> (cached clock) without proper clock cache updates, causing transaction time, wait time, and their percentiles to show extremely large incorrect values (e.g., 100+ seconds instead of actual milliseconds). The root cause was that the <code>quanta::Upkeep</code> handle was not being stored, causing the upkeep thread to stop immediately after starting. Now the handle is properly retained for the lifetime of the server, ensuring <code>Clock::recent()</code> returns accurate cached time values.</p>
</li>
<li>
<p><strong>Fixed query time accumulation bug in transaction loop</strong>: Query times were incorrectly accumulated when multiple queries were executed within a single transaction. The <code>query_start_at</code> timestamp was only set once at the beginning of the transaction, causing each subsequent query's elapsed time to include all previous queries' durations (e.g., 10 queries of 100ms each would report the last query as ~1 second instead of 100ms). Now <code>query_start_at</code> is updated for each new message in the transaction loop, ensuring accurate per-query timing.</p>
</li>
</ul>
<p><strong>New Features:</strong></p>
<ul>
<li>
<p><strong>New <code>clock_resolution_statistics</code> configuration parameter</strong>: Added <code>general.clock_resolution_statistics</code> parameter (default: <code>0.1ms</code> = 100 microseconds) that controls how often the internal clock cache is updated. Lower values provide more accurate timing measurements for query/transaction percentiles, while higher values reduce CPU overhead. This parameter affects the accuracy of all timing statistics reported in the admin console and Prometheus metrics.</p>
</li>
<li>
<p><strong>Sub-millisecond precision for Duration values</strong>: Duration configuration parameters now support sub-millisecond precision:</p>
<ul>
<li>New <code>us</code> suffix for microseconds (e.g., <code>"100us"</code> = 100 microseconds)</li>
<li>Decimal milliseconds support (e.g., <code>"0.1ms"</code> = 100 microseconds)</li>
<li>Internal representation changed from milliseconds to microseconds for higher precision</li>
<li>Full backward compatibility maintained: plain numbers are still interpreted as milliseconds</li>
</ul>
</li>
</ul>
<h3 id="315-jan-25-2026"><a class="header" href="#315-jan-25-2026">3.1.5 <small>Jan 25, 2026</small></a></h3>
<p><strong>Bug Fixes:</strong></p>
<ul>
<li><strong>Fixed PROTOCOL VIOLATION with batch PrepareAsync</strong></li>
<li><strong>Rewritten ParseComplete insertion algorithm</strong></li>
</ul>
<p><strong>Performance:</strong></p>
<ul>
<li><strong>Deferred connection acquisition for standalone BEGIN</strong>: When a client sends a standalone <code>BEGIN;</code> or <code>begin;</code> query (simple query protocol), the pooler now defers acquiring a server connection until the next message arrives. Since <code>BEGIN</code> itself doesn't perform any actual database operations, this optimization reduces connection pool contention when clients are slow to send their next query after starting a transaction.
<ul>
<li>Micro-optimized detection: first checks message size (12 bytes), then content using case-insensitive comparison</li>
<li>If client sends Terminate (<code>X</code>) after <code>BEGIN</code>, no server connection is acquired at all</li>
<li>The deferred <code>BEGIN</code> is automatically sent to the server before the actual query</li>
</ul>
</li>
</ul>
<h3 id="310-jan-18-2026"><a class="header" href="#310-jan-18-2026">3.1.0 <small>Jan 18, 2026</small></a></h3>
<p><strong>New Features:</strong></p>
<ul>
<li><strong>YAML configuration support</strong>: Added support for YAML configuration files (<code>.yaml</code>, <code>.yml</code>) as the primary and recommended format. The format is automatically detected based on file extension. TOML format remains fully supported for backward compatibility.
<ul>
<li>The <code>generate</code> command now outputs YAML or TOML based on the output file extension.</li>
<li>Include files can mix YAML and TOML formats.</li>
<li>New array syntax for users in YAML: <code>users: [{ username: "user1", ... }]</code></li>
</ul>
</li>
<li><strong>TOML backward compatibility</strong>: Full backward compatibility with legacy TOML format <code>[pools.*.users.0]</code> is maintained. Both the legacy map format and the new array format <code>[[pools.*.users]]</code> are supported.</li>
<li><strong>Username uniqueness validation</strong>: Added validation to reject duplicate usernames within a pool, ensuring configuration correctness.</li>
<li><strong>Human-readable configuration values</strong>: Duration and byte size parameters now support human-readable formats while maintaining backward compatibility with numeric values:
<ul>
<li>Duration: <code>"3s"</code>, <code>"5m"</code>, <code>"1h"</code>, <code>"1d"</code> (or milliseconds: <code>3000</code>)</li>
<li>Byte size: <code>"1MB"</code>, <code>"256M"</code>, <code>"1GB"</code> (or bytes: <code>1048576</code>)</li>
<li>Example: <code>connect_timeout: "3s"</code> instead of <code>connect_timeout: 3000</code></li>
</ul>
</li>
<li><strong>Foreground mode binary upgrade</strong>: Added support for binary upgrade in foreground mode by passing the listener socket to the new process via <code>--inherit-fd</code> argument. This enables zero-downtime upgrades without requiring daemon mode.</li>
<li><strong>Optional tokio runtime parameters</strong>: The following tokio runtime parameters are now optional and default to <code>None</code> (using tokio's built-in defaults): <code>tokio_global_queue_interval</code>, <code>tokio_event_interval</code>, <code>worker_stack_size</code>, and the new <code>max_blocking_threads</code>. Modern tokio versions handle these parameters well by default, so explicit configuration is no longer required in most cases.</li>
<li><strong>Improved graceful shutdown behavior</strong>:
<ul>
<li>During graceful shutdown, only clients with active transactions are now counted (instead of all connected clients), allowing faster shutdown when clients are idle.</li>
<li>After a client completes their transaction during shutdown, they receive a proper PostgreSQL protocol error (<code>58006 - pooler is shut down now</code>) instead of a connection reset.</li>
<li>Server connections are immediately released (marked as bad) after transaction completion during shutdown to conserve PostgreSQL connections.</li>
<li>All idle connections are immediately drained from pools when graceful shutdown starts, releasing PostgreSQL connections faster.</li>
</ul>
</li>
</ul>
<p><strong>Performance:</strong></p>
<ul>
<li><strong>Statistics module optimization</strong>: Major refactoring of the <code>src/stats</code> module for improved performance:
<ul>
<li>Replaced <code>VecDeque</code> with HDR histograms (<code>hdrhistogram</code> crate) for percentile calculations â€” O(1) percentile queries instead of O(n log n) sorting, ~95% memory reduction for latency tracking.</li>
<li>Histograms are now reset after each stats period (15 seconds) to provide accurate rolling window percentiles.</li>
</ul>
</li>
</ul>
<h3 id="305-jan-16-2026"><a class="header" href="#305-jan-16-2026">3.0.5 <small>Jan 16, 2026</small></a></h3>
<p><strong>Bug Fixes:</strong></p>
<ul>
<li>Fixed panic (<code>capacity overflow</code>) in startup message handling when receiving malformed messages with invalid length (less than 8 bytes or exceeding 10MB). Now gracefully rejects such connections with <code>ClientBadStartup</code> error.</li>
</ul>
<p><strong>Testing:</strong></p>
<ul>
<li><strong>Integration fuzz testing framework</strong>: Added comprehensive BDD-based fuzz tests (<code>@fuzz</code> tag) that verify pg_doorman's resilience to malformed PostgreSQL protocol messages.</li>
<li>All fuzz tests connect and authenticate first, then send malformed data to test post-authentication resilience.</li>
</ul>
<p><strong>CI/CD:</strong></p>
<ul>
<li>Added dedicated fuzz test job in GitHub Actions workflow (without retries, as fuzz tests should not be flaky).</li>
</ul>
<h3 id="304-jan-16-2026"><a class="header" href="#304-jan-16-2026">3.0.4 <small>Jan 16, 2026</small></a></h3>
<p><strong>New Features:</strong></p>
<ul>
<li><strong>Enhanced DEBUG logging for PostgreSQL protocol messages</strong>: Added grouped debug logging that displays message types in a compact format (e.g., <code>[P(stmt1),B,D,E,S]</code> or <code>[3xD,C,Z]</code>). Messages are buffered and flushed every 100ms or 100 messages to reduce log noise.</li>
<li><strong>Protocol violation detection</strong>: Added real-time protocol state tracking that detects and warns about protocol violations (e.g., receiving ParseComplete when no Parse was pending). Helps diagnose client-server synchronization issues.</li>
</ul>
<p><strong>Bug Fixes:</strong></p>
<ul>
<li>Fixed potential protocol violation when client disconnects during batch operations with cached prepared statements: disabled fast_release optimization when there are pending prepared statement operations.</li>
<li>Fixed ParseComplete insertion for Describe flow: now correctly inserts one ParseComplete before each ParameterDescription ('t') or NoData ('n') message instead of inserting all at once.</li>
</ul>
<h3 id="303-jan-15-2026"><a class="header" href="#303-jan-15-2026">3.0.3 <small>Jan 15, 2026</small></a></h3>
<p><strong>Bug Fixes:</strong></p>
<ul>
<li>Improved handling of Describe flow for cached prepared statements: added a separate counter (<code>pending_parse_complete_for_describe</code>) to correctly insert ParseComplete messages before ParameterDescription or NoData responses when Parse was skipped due to caching.</li>
</ul>
<p><strong>Testing:</strong></p>
<ul>
<li>Added comprehensive .NET client tests for Describe flow with cached prepared statements (<code>describe_flow_cached.cs</code>).</li>
<li>Added aggressive mixed tests combining batch operations, prepared statements, and extended protocol (<code>aggressive_mixed.cs</code>).</li>
</ul>
<h3 id="302-jan-14-2026"><a class="header" href="#302-jan-14-2026">3.0.2 <small>Jan 14, 2026</small></a></h3>
<p><strong>Bug Fixes:</strong></p>
<ul>
<li>Fixed protocol mismatch for .NET clients (Npgsql) using named prepared statements with <code>Prepare()</code>: ParseComplete messages are now correctly inserted before ParameterDescription and NoData messages in the Describe flow, not just before BindComplete.</li>
</ul>
<h3 id="301-jan-14-2026"><a class="header" href="#301-jan-14-2026">3.0.1 <small>Jan 14, 2026</small></a></h3>
<p><strong>Bug Fixes:</strong></p>
<ul>
<li>Fixed protocol mismatch for .NET clients (Npgsql): prevented insertion of ParseComplete messages between DataRow messages when server has more data available.</li>
</ul>
<p><strong>Testing:</strong></p>
<ul>
<li>Extended Node.js client test coverage with additional scenarios for prepared statements, error handling, transactions, and edge cases.</li>
</ul>
<h3 id="300-jan-12-2026"><a class="header" href="#300-jan-12-2026">3.0.0 <small>Jan 12, 2026</small></a></h3>
<p><strong>Major Release â€” Complete Architecture Refactoring</strong></p>
<p>This release represents a significant milestone with a complete codebase refactoring that dramatically improves async protocol support, making PgDoorman the most efficient connection pooler for asynchronous PostgreSQL workloads.</p>
<p><strong>New Features:</strong></p>
<ul>
<li><strong>patroni_proxy</strong> â€” A new high-performance TCP proxy for Patroni-managed PostgreSQL clusters:
<ul>
<li>Zero-downtime connection management â€” existing connections are preserved during cluster topology changes</li>
<li>Hot upstream updates â€” automatic discovery of cluster members via Patroni REST API without connection drops</li>
<li>Role-based routing â€” route connections to leader, sync replicas, or async replicas based on configuration</li>
<li>Replication lag awareness with configurable <code>max_lag_in_bytes</code> per port</li>
<li>Least connections load balancing strategy</li>
</ul>
</li>
</ul>
<p><strong>Improvements:</strong></p>
<ul>
<li><strong>Complete codebase refactoring</strong> â€” modular architecture with better separation of concerns:
<ul>
<li>Client handling split into dedicated modules (core, entrypoint, protocol, startup, transaction)</li>
<li>Configuration system reorganized into focused modules (general, pool, user, tls, prometheus, talos)</li>
<li>Admin, auth, and prometheus subsystems extracted into separate modules</li>
<li>Improved code maintainability and testability</li>
</ul>
</li>
<li><strong>Enhanced async protocol support</strong> â€” significantly improved handling of asynchronous PostgreSQL protocol, providing better performance than other connection poolers for async workloads</li>
<li><strong>Extended protocol improvements</strong> â€” better client buffering and message handling for extended query protocol</li>
<li><strong>xxhash3 for prepared statement hashing</strong> â€” faster hash computation for prepared statement cache</li>
<li><strong>Comprehensive BDD testing framework</strong> â€” multi-language integration tests (Go, Rust, Python, Node.js, .NET) with Docker-based reproducible environment</li>
</ul>
<h3 id="250-nov-18-2025"><a class="header" href="#250-nov-18-2025">2.5.0 <small>Nov 18, 2025</small></a></h3>
<p><strong>Improvements:</strong></p>
<ul>
<li>Reworked the statistics collection system, yielding up to 20% performance gain on fast queries.</li>
<li>Improved detection of <code>SAVEPOINT</code> usage, allowing the auto-rollback feature to be applied in more situations.</li>
</ul>
<p><strong>Bug Fixes / Behavior:</strong></p>
<ul>
<li>Less aggressive behavior on write errors when sending a response to the client: the server connection is no longer immediately marked as "bad" and evicted from the pool. We now read the remaining server response and clean up its state, returning the connection to the pool in a clean state. This improves performance during client reconnections.</li>
</ul>
<h3 id="243-nov-15-2025"><a class="header" href="#243-nov-15-2025">2.4.3 <small>Nov 15, 2025</small></a></h3>
<p><strong>Bug Fixes:</strong></p>
<ul>
<li>Fixed handling of nested transactions via <code>SAVEPOINT</code>: auto-rollback now correctly rolls back to the savepoint instead of breaking the outer transaction. This prevents clients from getting stuck in an inconsistent transactional state.</li>
</ul>
<h3 id="242-nov-13-2025"><a class="header" href="#242-nov-13-2025">2.4.2 <small>Nov 13, 2025</small></a></h3>
<p><strong>Improvements:</strong></p>
<ul>
<li><code>pg_hba</code> rules now apply to the admin console as well; the <code>trust</code> method can be used for admin connections when a matching rule is present (use with caution; restrict by address/TLS).</li>
</ul>
<p><strong>Bug Fixes:</strong></p>
<ul>
<li>Fixed <code>pg_hba</code> evaluation: <code>local</code> records were mistakenly considered; PgDoorman only handles TCP connections, so <code>local</code> entries are now correctly ignored.</li>
</ul>
<h3 id="241-nov-12-2025"><a class="header" href="#241-nov-12-2025">2.4.1 <small>Nov 12, 2025</small></a></h3>
<p><strong>Improvements:</strong></p>
<ul>
<li>Performance optimizations in request handling and message processing paths to reduce latency and CPU usage.</li>
<li><code>pg_hba</code> rules now apply to the admin console as well; the <code>trust</code> method can be used for admin connections when a matching rule is present (use with caution; restrict by address/TLS).</li>
</ul>
<p><strong>Bug Fixes:</strong></p>
<ul>
<li>Corrected logic where <code>COMMIT</code> could be mishandled similarly to <code>ROLLBACK</code> in certain error states; now transactional state handling is aligned with PostgreSQL semantics.</li>
</ul>
<h3 id="240-nov-10-2025"><a class="header" href="#240-nov-10-2025">2.4.0 <small>Nov 10, 2025</small></a></h3>
<p><strong>Features:</strong></p>
<ul>
<li>Added <code>pg_hba</code> support to control client access in PostgreSQL format. New <code>general.pg_hba</code> setting supports inline content or file path.</li>
<li>Clients that enter the <code>aborted in transaction</code> state are detached from their server backend; the proxy waits for the client to send <code>ROLLBACK</code>.</li>
</ul>
<p><strong>Improvements:</strong></p>
<ul>
<li>Refined admin and metrics counters: separated <code>cancel</code> connections and corrected calculation of <code>error</code> connections in admin output and Prometheus metrics descriptions.</li>
<li>Added configuration validation to prevent simultaneous use of legacy <code>general.hba</code> CIDR list with the new <code>general.pg_hba</code> rules.</li>
<li>Improved validation and error messages for Talos token authentication.</li>
</ul>
<h3 id="222-aug-17-2025"><a class="header" href="#222-aug-17-2025">2.2.2 <small>Aug 17, 2025</small></a></h3>
<p><strong>Features:</strong></p>
<ul>
<li>Added new generate feature functionality</li>
</ul>
<p><strong>Bug Fixes:</strong></p>
<ul>
<li>Fixed deallocate issues with PGX5 compatibility</li>
</ul>
<h3 id="221-aug-6-2025"><a class="header" href="#221-aug-6-2025">2.2.1 <small>Aug 6, 2025</small></a></h3>
<p><strong>Features:</strong></p>
<ul>
<li>Improve Prometheus exporter functionality</li>
</ul>
<h3 id="220-aug-5-2025"><a class="header" href="#220-aug-5-2025">2.2.0 <small>Aug 5, 2025</small></a></h3>
<p><strong>Features:</strong></p>
<ul>
<li>Added Prometheus exporter functionality that provides metrics about connections, memory usage, pools, queries, and transactions</li>
</ul>
<h3 id="212-aug-4-2025"><a class="header" href="#212-aug-4-2025">2.1.2 <small>Aug 4, 2025</small></a></h3>
<p><strong>Features:</strong></p>
<ul>
<li>Added docker image <code>ghcr.io/ozontech/pg_doorman</code></li>
</ul>
<h3 id="210-aug-1-2025"><a class="header" href="#210-aug-1-2025">2.1.0 <small>Aug 1, 2025</small></a></h3>
<p><strong>Features:</strong></p>
<ul>
<li>The new command <code>generate</code> connects to your PostgreSQL server, automatically detects all databases and users, and creates a complete configuration file with appropriate settings. This is especially useful for quickly setting up PgDoorman in new environments or when you have many databases and users to configure.</li>
</ul>
<h3 id="201-july-24-2025"><a class="header" href="#201-july-24-2025">2.0.1 <small>July 24, 2025</small></a></h3>
<p><strong>Bug Fixes:</strong></p>
<ul>
<li>Fixed <code>max_memory_usage</code> counter leak when clients disconnect improperly.</li>
</ul>
<h3 id="200-july-22-2025"><a class="header" href="#200-july-22-2025">2.0.0 <small>July 22, 2025</small></a></h3>
<p><strong>Features:</strong></p>
<ul>
<li>Added <code>tls_mode</code> configuration option to enhance security with flexible TLS connection management and client certificate validation capabilities.</li>
</ul>
<h3 id="190-july-20-2025"><a class="header" href="#190-july-20-2025">1.9.0 <small>July 20, 2025</small></a></h3>
<p><strong>Features:</strong></p>
<ul>
<li>Added PAM authentication support.</li>
<li>Added <code>talos</code> JWT authentication support.</li>
</ul>
<p><strong>Improvements:</strong></p>
<ul>
<li>Implemented streaming for COPY protocol with large columns to prevent memory exhaustion.</li>
<li>Updated Rust and Tokio dependencies.</li>
</ul>
<h3 id="183-jun-11-2025"><a class="header" href="#183-jun-11-2025">1.8.3 <small>Jun 11, 2025</small></a></h3>
<p><strong>Bug Fixes:</strong></p>
<ul>
<li>Fixed critical bug where Client's buffer wasn't cleared when no free connections were available in the Server pool (query_wait_timeout), leading to incorrect response errors. <a href="https://github.com/ozontech/pg_doorman/pull/38">#38</a></li>
<li>Fixed Npgsql-related issue. <a href="https://github.com/npgsql/npgsql/issues/6115">Npgsql#6115</a></li>
</ul>
<h3 id="182-may-24-2025"><a class="header" href="#182-may-24-2025">1.8.2 <small>May 24, 2025</small></a></h3>
<p><strong>Features:</strong></p>
<ul>
<li>Added <code>application_name</code> parameter in pool. <a href="https://github.com/ozontech/pg_doorman/pull/30">#30</a></li>
<li>Added support for <code>DISCARD ALL</code> and <code>DEALLOCATE ALL</code> client queries.</li>
</ul>
<p><strong>Improvements:</strong></p>
<ul>
<li>Implemented link-time optimization. <a href="https://github.com/ozontech/pg_doorman/pull/29">#29</a></li>
</ul>
<p><strong>Bug Fixes:</strong></p>
<ul>
<li>Fixed panics in admin console.</li>
<li>Fixed connection leakage on improperly handled errors in client's copy mode.</li>
</ul>
<h3 id="181-april-12-2025"><a class="header" href="#181-april-12-2025">1.8.1 <small>April 12, 2025</small></a></h3>
<p><strong>Bug Fixes:</strong></p>
<ul>
<li>Fixed config value of prepared_statements. <a href="https://github.com/ozontech/pg_doorman/pull/21">#21</a></li>
<li>Fixed handling of declared cursors closure. <a href="https://github.com/ozontech/pg_doorman/pull/23">#23</a></li>
<li>Fixed proxy server parameters. <a href="https://github.com/ozontech/pg_doorman/pull/25">#25</a></li>
</ul>
<h3 id="180-mar-20-2025"><a class="header" href="#180-mar-20-2025">1.8.0 <small>Mar 20, 2025</small></a></h3>
<p><strong>Bug Fixes:</strong></p>
<ul>
<li>Fixed dependencies issue. <a href="https://github.com/ozontech/pg_doorman/pull/15">#15</a></li>
</ul>
<p><strong>Improvements:</strong></p>
<ul>
<li>Added release vendor-licenses.txt file. <a href="https://www.postgresql.org/message-id/flat/CAMp%2BueYqZNwA5SnZV3-iPOyrmQwnwabyMNMOsu-Rq0sLAa2b0g%40mail.gmail.com">Related thread</a></li>
</ul>
<h3 id="179-mar-16-2025"><a class="header" href="#179-mar-16-2025">1.7.9 <small>Mar 16, 2025</small></a></h3>
<p><strong>Improvements:</strong></p>
<ul>
<li>Added release vendor.tar.gz for offline build. <a href="https://www.postgresql.org/message-id/flat/CAMp%2BueYqZNwA5SnZV3-iPOyrmQwnwabyMNMOsu-Rq0sLAa2b0g%40mail.gmail.com">Related thread</a></li>
</ul>
<p><strong>Bug Fixes:</strong></p>
<ul>
<li>Fixed issues with pqCancel messages over TLS protocol. Drivers should send pqCancel messages exclusively via TLS if the primary connection was established using TLS. <a href="https://github.com/npgsql/npgsql">Npgsql</a> follows this rule, while <a href="https://github.com/jackc/pgx">PGX</a> currently does not. Both behaviors are now supported.</li>
</ul>
<h3 id="178-mar-8-2025"><a class="header" href="#178-mar-8-2025">1.7.8 <small>Mar 8, 2025</small></a></h3>
<p><strong>Bug Fixes:</strong></p>
<ul>
<li>Fixed message ordering issue when using batch processing with the extended protocol.</li>
<li>Improved error message detail in logs for server-side login attempt failures.</li>
</ul>
<h3 id="177-mar-8-2025"><a class="header" href="#177-mar-8-2025">1.7.7 <small>Mar 8, 2025</small></a></h3>
<p><strong>Features:</strong></p>
<ul>
<li>Enhanced <code>show clients</code> command with new fields: <code>state</code> (waiting/idle/active) and <code>wait</code> (read/write/idle).</li>
<li>Enhanced <code>show servers</code> command with new fields: <code>state</code> (login/idle/active), <code>wait</code> (read/write/idle), and <code>server_process_pid</code>.</li>
<li>Added 15-second proxy timeout for streaming large <code>message_size_to_be_stream</code> responses.</li>
</ul>
<p><strong>Bug Fixes:</strong></p>
<ul>
<li>Fixed <code>max_memory_usage</code> counter leak when clients disconnect improperly.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-to-pgdoorman"><a class="header" href="#contributing-to-pgdoorman">Contributing to PgDoorman</a></h1>
<p>Thank you for your interest in contributing to PgDoorman! This guide will help you set up your development environment and understand the contribution process.</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<h3 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h3>
<p>For running integration tests, you only need:</p>
<ul>
<li><a href="https://docs.docker.com/get-docker/">Docker</a> (required)</li>
<li><a href="https://www.gnu.org/software/make/">Make</a> (required)</li>
</ul>
<p><strong>Nix installation is NOT required</strong> â€” test environment reproducibility is ensured by Docker containers built with Nix.</p>
<p>For local development (optional):</p>
<ul>
<li><a href="https://www.rust-lang.org/tools/install">Rust</a> (latest stable version)</li>
<li><a href="https://git-scm.com/downloads">Git</a></li>
</ul>
<h3 id="setting-up-your-development-environment"><a class="header" href="#setting-up-your-development-environment">Setting Up Your Development Environment</a></h3>
<ol>
<li><strong>Fork the repository</strong> on GitHub</li>
<li><strong>Clone your fork</strong>:
<pre><code class="language-bash">git clone https://github.com/YOUR-USERNAME/pg_doorman.git
cd pg_doorman
</code></pre>
</li>
<li><strong>Add the upstream repository</strong>:
<pre><code class="language-bash">git remote add upstream https://github.com/ozontech/pg_doorman.git
</code></pre>
</li>
</ol>
<h2 id="local-development"><a class="header" href="#local-development">Local Development</a></h2>
<ol>
<li>
<p><strong>Build the project</strong>:</p>
<pre><code class="language-bash">cargo build
</code></pre>
</li>
<li>
<p><strong>Build for performance testing</strong>:</p>
<pre><code class="language-bash">cargo build --release
</code></pre>
</li>
<li>
<p><strong>Configure PgDoorman</strong>:</p>
<ul>
<li>Copy the example configuration: <code>cp pg_doorman.toml.example pg_doorman.toml</code></li>
<li>Adjust the configuration in <code>pg_doorman.toml</code> to match your setup</li>
</ul>
</li>
<li>
<p><strong>Run PgDoorman</strong>:</p>
<pre><code class="language-bash">cargo run --release
</code></pre>
</li>
<li>
<p><strong>Run unit tests</strong>:</p>
<pre><code class="language-bash">cargo test
</code></pre>
</li>
</ol>
<h2 id="integration-testing"><a class="header" href="#integration-testing">Integration Testing</a></h2>
<p>PgDoorman uses BDD (Behavior-Driven Development) tests with a Docker-based test environment. <strong>Reproducibility is guaranteed</strong> â€” all tests run inside Docker containers with identical environments.</p>
<h3 id="test-environment-1"><a class="header" href="#test-environment-1">Test Environment</a></h3>
<p>The test Docker image (built with Nix) includes:</p>
<ul>
<li>PostgreSQL 16</li>
<li>Go 1.24</li>
<li>Python 3 with asyncpg, psycopg2, aiopg, pytest</li>
<li>Node.js 22</li>
<li>.NET SDK 8</li>
<li>Rust 1.87.0</li>
</ul>
<h3 id="running-tests"><a class="header" href="#running-tests">Running Tests</a></h3>
<p>From the <strong>project root directory</strong>:</p>
<pre><code class="language-bash"># Pull the test image from registry
make pull

# Or build locally (takes 10-15 minutes on first run)
make local-build

# Run all BDD tests
make test-bdd

# Run tests with specific tag
make test-bdd TAGS=@copy-protocol
make test-bdd TAGS=@cancel
make test-bdd TAGS=@admin-commands

# Open interactive shell in test container
make shell
</code></pre>
<h3 id="debug-mode"><a class="header" href="#debug-mode">Debug Mode</a></h3>
<p>Enable debug output with the <code>DEBUG=1</code> environment variable:</p>
<pre><code class="language-bash">DEBUG=1 make test-bdd TAGS=@copy-protocol
</code></pre>
<p>When <code>DEBUG=1</code> is set:</p>
<ul>
<li>Tracing is enabled with DEBUG level</li>
<li>Thread IDs are shown in logs</li>
<li>Line numbers are included</li>
<li>PostgreSQL protocol details are visible</li>
<li>Detailed step-by-step execution is logged</li>
</ul>
<p>This is useful when:</p>
<ul>
<li>Debugging failing tests</li>
<li>Understanding protocol-level communication</li>
<li>Investigating timing issues</li>
<li>Developing new test scenarios</li>
</ul>
<h3 id="available-test-tags"><a class="header" href="#available-test-tags">Available Test Tags</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Tag</th><th>Description</th></tr></thead><tbody>
<tr><td><code>@go</code></td><td>Go client tests</td></tr>
<tr><td><code>@python</code></td><td>Python client tests</td></tr>
<tr><td><code>@nodejs</code></td><td>Node.js client tests</td></tr>
<tr><td><code>@dotnet</code></td><td>.NET client tests</td></tr>
<tr><td><code>@rust</code></td><td>Rust protocol-level tests</td></tr>
<tr><td><code>@copy-protocol</code></td><td>COPY protocol tests</td></tr>
<tr><td><code>@cancel</code></td><td>Query cancellation tests</td></tr>
<tr><td><code>@admin-commands</code></td><td>Admin console commands</td></tr>
<tr><td><code>@admin-leak</code></td><td>Admin connection leak tests</td></tr>
<tr><td><code>@buffer-cleanup</code></td><td>Buffer cleanup tests</td></tr>
<tr><td><code>@rollback</code></td><td>Rollback functionality tests</td></tr>
<tr><td><code>@hba</code></td><td>HBA authentication tests</td></tr>
<tr><td><code>@prometheus</code></td><td>Prometheus metrics tests</td></tr>
</tbody></table>
</div>
<h2 id="writing-new-tests"><a class="header" href="#writing-new-tests">Writing New Tests</a></h2>
<p>Tests are organized as BDD feature files in <code>tests/bdd/features/</code>. Each feature file describes test scenarios using Gherkin syntax.</p>
<h3 id="shell-tests-recommended-for-client-libraries"><a class="header" href="#shell-tests-recommended-for-client-libraries">Shell Tests (Recommended for Client Libraries)</a></h3>
<p>Shell tests run external test commands (Go, Python, Node.js, etc.) and verify their output. This is the simplest way to test client library compatibility.</p>
<p><strong>Example</strong> (<code>tests/bdd/features/my-feature.feature</code>):</p>
<pre><code class="language-gherkin">@go @mytag
Feature: My feature description

  Background:
    Given PostgreSQL started with pg_hba.conf:
      """
      local all all trust
      host all all 127.0.0.1/32 trust
      """
    And fixtures from "tests/fixture.sql" applied
    And pg_doorman started with config:
      """
      [general]
      host = "127.0.0.1"
      port = ${DOORMAN_PORT}
      admin_username = "admin"
      admin_password = "admin"

      [pools.example_db]
      server_host = "127.0.0.1"
      server_port = ${PG_PORT}

      [pools.example_db.users.0]
      username = "example_user_1"
      password = "md58a67a0c805a5ee0384ea28e0dea557b6"
      pool_size = 40
      """

  Scenario: Test my Go client
    When I run shell command:
      """
      export DATABASE_URL="postgresql://example_user_1:test@127.0.0.1:${DOORMAN_PORT}/example_db?sslmode=disable"
      cd tests/go &amp;&amp; go test -v -run TestMyTest ./mypackage
      """
    Then the command should succeed
    And the command output should contain "PASS"
</code></pre>
<p><strong>Test implementation</strong> (in your preferred language):</p>
<ul>
<li>Go: <code>tests/go/mypackage/my_test.go</code></li>
<li>Python: <code>tests/python/test_my.py</code></li>
<li>Node.js: <code>tests/nodejs/my.test.js</code></li>
<li>.NET: <code>tests/dotnet/MyTest.cs</code></li>
</ul>
<h3 id="rust-protocol-level-tests"><a class="header" href="#rust-protocol-level-tests">Rust Protocol-Level Tests</a></h3>
<p>For testing PostgreSQL protocol behavior at the wire level, use Rust-based tests. These tests directly send and receive PostgreSQL protocol messages, allowing precise control and comparison.</p>
<p><strong>Example</strong> (<code>tests/bdd/features/protocol-test.feature</code>):</p>
<pre><code class="language-gherkin">@rust @my-protocol-test
Feature: Protocol behavior test
  Testing that pg_doorman handles protocol messages identically to PostgreSQL

  Background:
    Given PostgreSQL started with pg_hba.conf:
      """
      local all all trust
      host all all 127.0.0.1/32 trust
      """
    And fixtures from "tests/fixture.sql" applied
    And pg_doorman started with config:
      """
      [general]
      host = "127.0.0.1"
      port = ${DOORMAN_PORT}
      admin_username = "admin"
      admin_password = "admin"
      pg_hba.content = "host all all 127.0.0.1/32 trust"

      [pools.example_db]
      server_host = "127.0.0.1"
      server_port = ${PG_PORT}

      [pools.example_db.users.0]
      username = "example_user_1"
      password = ""
      pool_size = 10
      """

  @my-scenario
  Scenario: Query gives identical results from PostgreSQL and pg_doorman
    When we login to postgres and pg_doorman as "example_user_1" with password "" and database "example_db"
    And we send SimpleQuery "SELECT 1" to both
    Then we should receive identical messages from both

  @session-test
  Scenario: Session management test
    When we create session "one" to pg_doorman as "example_user_1" with password "" and database "example_db"
    And we send SimpleQuery "BEGIN" to session "one"
    And we send SimpleQuery "SELECT pg_backend_pid()" to session "one" and store backend_pid
    # ... more steps
</code></pre>
<p><strong>Available Rust test steps:</strong></p>
<p>Protocol comparison (sends to both PostgreSQL and pg_doorman):</p>
<ul>
<li><code>we login to postgres and pg_doorman as "user" with password "pass" and database "db"</code></li>
<li><code>we send SimpleQuery "SQL" to both</code></li>
<li><code>we send CopyFromStdin "COPY ..." with data "..." to both</code></li>
<li><code>we should receive identical messages from both</code></li>
</ul>
<p>Session management (for complex scenarios):</p>
<ul>
<li><code>we create session "name" to pg_doorman as "user" with password "pass" and database "db"</code></li>
<li><code>we send SimpleQuery "SQL" to session "name"</code></li>
<li><code>we send SimpleQuery "SQL" to session "name" and store backend_pid</code></li>
<li><code>we abort TCP connection for session "name"</code></li>
<li><code>we sleep 100ms</code></li>
</ul>
<p>Cancel request testing:</p>
<ul>
<li><code>we create session "name" ... and store backend key</code></li>
<li><code>we send SimpleQuery "SQL" to session "name" without waiting for response</code></li>
<li><code>we send cancel request for session "name"</code></li>
<li><code>session "name" should receive cancel error containing "text"</code></li>
</ul>
<h3 id="adding-dependencies"><a class="header" href="#adding-dependencies">Adding Dependencies</a></h3>
<p>If you need additional packages in the test environment, modify <code>tests/nix/flake.nix</code>:</p>
<ul>
<li>Add Python packages to <code>pythonEnv</code></li>
<li>Add system packages to <code>runtimePackages</code></li>
</ul>
<p>After modifying <code>flake.nix</code>, rebuild the image with <code>make local-build</code>.</p>
<h2 id="contribution-guidelines"><a class="header" href="#contribution-guidelines">Contribution Guidelines</a></h2>
<h3 id="code-style"><a class="header" href="#code-style">Code Style</a></h3>
<ul>
<li>Follow the Rust style guidelines</li>
<li>Use meaningful variable and function names</li>
<li>Add comments for complex logic</li>
<li>Write tests for new functionality</li>
</ul>
<h3 id="pull-request-process"><a class="header" href="#pull-request-process">Pull Request Process</a></h3>
<ol>
<li><strong>Create a new branch</strong> for your feature or bugfix</li>
<li><strong>Make your changes</strong> and commit them with clear, descriptive messages</li>
<li><strong>Write or update tests</strong> as necessary</li>
<li><strong>Update documentation</strong> to reflect any changes</li>
<li><strong>Submit a pull request</strong> to the main repository</li>
<li><strong>Address any feedback</strong> from code reviews</li>
</ol>
<h3 id="reporting-issues"><a class="header" href="#reporting-issues">Reporting Issues</a></h3>
<p>If you find a bug or have a feature request, please create an issue on the <a href="https://github.com/ozontech/pg_doorman/issues">GitHub repository</a> with:</p>
<ul>
<li>A clear, descriptive title</li>
<li>A detailed description of the issue or feature</li>
<li>Steps to reproduce (for bugs)</li>
<li>Expected and actual behavior (for bugs)</li>
</ul>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<p>If you need help with your contribution, you can:</p>
<ul>
<li>Ask questions in the GitHub issues</li>
<li>Reach out to the maintainers</li>
</ul>
<p>Thank you for contributing to PgDoorman!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid-init.js"></script>
        <script src="mermaid.min.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
