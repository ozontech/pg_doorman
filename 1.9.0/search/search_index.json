{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#pgdoorman-postgresql-pooler","title":"PgDoorman: PostgreSQL Pooler","text":"<p>PgDoorman is a stable and good alternative to PgBouncer, Odyssey, or PgCat (based on it). It has created with the Unix philosophy in mind. Developing was focused on perfomance, efficience and reliability. Also, PgDoorman has the improved driver support for languages like Go (pgx), .NET (npgsql), and asynchronous drivers for Python and Node.js.</p> <p> Get PgDoorman 1.9.0</p>"},{"location":"#why-not-multi-pgbouncer","title":"Why not multi-PgBouncer?","text":"<p>Why do we think that using multiple instances of PgBouncer is not a suitable solution? This approach has problems with reusing prepared statements and strange and inefficient control over query cancellation. Additionally, the main issue we have encountered is that the operating system distributes new clients round-robin, but each client can disconnect at any time, leading to an imbalance after prolonged use.</p>"},{"location":"#why-not-odyssey","title":"Why not Odyssey?","text":"<p>We had difficulties using NPGSQL and SCRAM, as well as with <code>prepared_statements</code> support. However, the main serious problem related to data consistency and, for a long time, we were unable to solve it.</p>"},{"location":"#differences-from-pgcat","title":"Differences from PgCat","text":"<p>While PgDoorman was initially based on the PgCat project, it has since evolved into a standalone solution with its own set of features. Some of the key differences include:</p> <ul> <li>Performance improvements compared to PgCat/PgBouncer/Odyssey.</li> <li>Support for extended protocol with popular programming language drivers.</li> <li>Enhanced monitoring metrics to improve visibility into database activity..</li> <li>Careful resource management to avoid memory issues (<code>max_memory_usage</code>, <code>message_size_to_be_stream</code>).</li> <li>SCRAM client/server authentication support.</li> <li>Gracefully binary upgrade.</li> <li>Supporting JWT for service-to-database authentication.</li> <li>Many micro-optimizations (for example, the time spent with the client is longer than the server's busy time).</li> </ul>"},{"location":"benchmarks/","title":"Benchmarks","text":""},{"location":"benchmarks/#disclaimer","title":"Disclaimer:","text":"<p>Benchmarks always lie to you :) We recommend that you benchmark the application yourself and verify the results. The current benchmarks provided here are intended to give you an idea of approximate figures.</p> <p>In addition to being fast, a pooler should also be predictable and error-free. While benchmarks may not provide real-world experience, they can reveal potential problems.</p>"},{"location":"benchmarks/#smoke-perf-test","title":"Smoke perf test","text":"<p>PG 15, CPU 20, pool_size = 40, client with SCRAM auth.</p>"},{"location":"benchmarks/#prepared-without-ssl","title":"Prepared without SSL:","text":"<pre><code>PGSSLMODE=disable pgbench -s 10 -T 600 -P 1 -S -n -j 4 -c 80 -M prepared -r\n</code></pre> Pooler Usage TPS PostgreSQL - 230_000 PgBouncer 1 CPU 45_000 Odyssey 5-6 CPU 125_000 PgCat - - PgDoorman 6-7 CPU 135_000 <p>Notes:   + pgcat (1.3.0) settings: <code>prepared_statements_cache_size = 500</code>, but prepared with pgbench is not working.</p>"},{"location":"benchmarks/#simple-without-ssl","title":"Simple without SSL:","text":"<pre><code>PGSSLMODE=disable pgbench -s 10 -T 600 -P 1 -S -n -j 4 -c 80 -r\n</code></pre> Pooler Usage TPS PostgreSQL - 150_000 PgBouncer 1 CPU 60_000 Odyssey 4 CPU 105_000 PgCat 3-4 CPU 85_000 PgDoorman 4-5 CPU 110_000"},{"location":"benchmarks/#reconnect-with-ssl","title":"Reconnect with SSL:","text":"<pre><code>PGSSLMODE=require PGHOST=10.251.28.154 pgbench -s 10 -T 600 -P 1 -S -n -j 4 -c 80 -M prepared -r -C\n</code></pre> Pooler Usage TPS PostgreSQL - 190 PgBouncer 1 CPU 240 Odyssey 1 CPU 260 PgCat 1 CPU 530 PgDoorman 1 CPU 260 <p>Notes:    + odyssey irregular errors: <code>error: connection to server at \"10.251.28.154\", port 6432 failed: ERROR:  odyssey: c3d386c5e5c2f: password authentication failed</code>.   + pgcat (rutls) is faster pg_doorman (openssl), but we experienced problems when using this library (rutls) with npgsql, and we had switched to openssl-wrappers.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#1.9.0","title":"1.9.0 July 20, 2025","text":"<ul> <li>Added pam auth support.</li> <li>Added <code>talos</code> (yet another jwt auth support).</li> <li>When using the COPY protocol, if a row contains a large column, pg_doorman may run out of memory. Now this happens when streaming, when the response is not stored in memory.</li> <li>Updating rust and tokio.</li> </ul>"},{"location":"changelog/#1.8.3","title":"1.8.3 Jun 11, 2025","text":"<ul> <li>Fixed critical bug: if a free connection was not available on the Server in pool (query_wait_timeout), the Client's buffer was not cleared, leading to an incorrect response error #38.</li> <li>Fixed ngsql-related issue: https://github.com/npgsql/npgsql/issues/6115.</li> </ul>"},{"location":"changelog/#1.8.2","title":"1.8.2 May 24, 2025","text":"<ul> <li>Added <code>application_name</code> parameter in pool #30.</li> <li>Added link-time optimization #29.</li> <li>Added <code>DISCARD ALL</code>/<code>DEALLOCATE ALL</code> client query support.</li> <li>Fixed panics in admin console.</li> <li>Fixed connection leakage on inproperly handled errors in client's copy mode</li> </ul>"},{"location":"changelog/#1.8.1","title":"1.8.1 April 12, 2025","text":"<ul> <li>Fixed config value of prepared_statements #21.</li> <li>Fixed close declared cursors #23.</li> <li>Fixed proxy server parameters #25.</li> </ul>"},{"location":"changelog/#1.8.0","title":"1.8.0 Mar 20, 2025","text":"<ul> <li>Fixed #15: Dependencies</li> <li>Added release vendor-licenses.txt, related thread.</li> </ul>"},{"location":"changelog/#1.7.9","title":"1.7.9 Mar 16, 2025","text":"<ul> <li> <p>Added release vendor.tar.gz for offline build, related thread.</p> </li> <li> <p>Fixed This update addresses issues related to the inability to send pqCancel messages over the TLS protocol.  To clarify, drivers should send pqCancel messages exclusively via TLS if the primary connection was established using TLS. Npgsql strictly adheres to this rule, however, PGX currently does not follow this flow, potentially leading to inconsistencies in secure connection handling (aka hostssl). Both of these behaviors are currently supported and functional.</p> </li> </ul>"},{"location":"changelog/#1.7.8","title":"1.7.8 Mar 8, 2025","text":"<ul> <li>Fixed In some cases, when using batch processing with the extended protocol, messages were delivered to the client in the wrong order.</li> <li>Fixed Error messages in the log lacked sufficient detail to diagnose issues encountered during server-side login attempts.</li> </ul>"},{"location":"changelog/#1.7.7","title":"1.7.7 Mar 8, 2025","text":"<ul> <li>Added <code>show clients</code>: added <code>state</code> (waiting/idle/active), <code>wait</code> (read/write/idle) fields.</li> <li>Added <code>show servers</code>: added <code>state</code> (login/idle/active), <code>wait</code> (read/write/idle), <code>server_process_pid</code> fields.</li> <li>Added The proxy timeout for streaming large <code>message_size_to_be_stream</code> responses is now set to 15 seconds.</li> <li>Fixed counter <code>max_memory_usage</code> leak when clients disconnect improperly.</li> </ul>"},{"location":"reference/settings/","title":"Settings","text":""},{"location":"reference/settings/#general-settings","title":"General Settings","text":""},{"location":"reference/settings/#host","title":"host","text":"<p>Listen host (TCP v4 only).</p> <p>Default: <code>\"0.0.0.0\"</code>.</p>"},{"location":"reference/settings/#port","title":"port","text":"<p>Listen port for incoming connections.</p> <p>Default: <code>6432</code>.</p>"},{"location":"reference/settings/#backlog","title":"backlog","text":"<p>TCP backlog for incoming connections. A value of zero sets the <code>max_connections</code> as value for the TCP backlog.</p> <p>Default: <code>0</code>.</p>"},{"location":"reference/settings/#max_connections","title":"max_connections","text":"<p>The maximum number of clients that can connect to the pooler simultaneously. When this limit is reached: * A client connecting without SSL will receive the expected error (code: <code>53300</code>, message: <code>sorry, too many clients already</code>). * A client connecting via SSL will see a message indicating that the server does not support the SSL protocol.</p> <p>Default: <code>8192</code>.</p>"},{"location":"reference/settings/#tls_private_key","title":"tls_private_key","text":"<p>It is necessary to allow the processing of incoming connections from TLS clients.</p> <p>Default: <code>None</code>.</p>"},{"location":"reference/settings/#tls_certificate","title":"tls_certificate","text":"<p>It is necessary to allow the processing of incoming connections from TLS clients.</p> <p>Default: <code>None</code>.</p>"},{"location":"reference/settings/#tls_rate_limit_per_second","title":"tls_rate_limit_per_second","text":"<p>Limit the number of simultaneous attempts to create a TLS session. Any value other than zero implies that there is a queue through which clients must pass in order to establish a TLS connection. In some cases, this is necessary in order to launch an application that opens many connections at startup (the so-called \"hot start\").</p> <p>Default: <code>0</code>.</p>"},{"location":"reference/settings/#daemon_pid_file","title":"daemon_pid_file","text":"<p>Enabling this setting enables daemon mode. Comment this out if you want to run pg_doorman in the foreground with <code>-d</code>.</p> <p>Default: <code>None</code>.</p>"},{"location":"reference/settings/#syslog_prog_name","title":"syslog_prog_name","text":"<p>When specified, pg_doorman starts sending messages to syslog (using /dev/log or /var/run/syslog). Comment this out if you want to log to stdout.</p> <p>Default: <code>None</code>.</p>"},{"location":"reference/settings/#log_client_connections","title":"log_client_connections","text":"<p>Log client connections and disconnections for monitoring.</p> <p>Default: <code>false</code>.</p>"},{"location":"reference/settings/#log_client_disconnections","title":"log_client_disconnections","text":"<p>Log client connections and disconnections for monitoring.</p> <p>Default: <code>false</code>.</p>"},{"location":"reference/settings/#worker_threads","title":"worker_threads","text":"<p>The number of worker processes (posix threads) that async serve clients, which affects the performance of pg_doorman. The more workers there are, the faster the system works, but only up to a certain limit (cpu count). If you already have a lot of workers, you should consider increasing the number of virtual pools.</p> <p>Default: <code>4</code>.</p>"},{"location":"reference/settings/#worker_cpu_affinity_pinning","title":"worker_cpu_affinity_pinning","text":"<p>Automatically assign workers to different CPUs (man 3 cpu_set).</p> <p>Default: <code>false</code>.</p>"},{"location":"reference/settings/#virtual_pool_count","title":"virtual_pool_count","text":"<p>Increasing the number of virtual pools can help deal with internal latches that occur when processing very large numbers of fast queries. It is strongly recommended not to change this parameter if you do not understand what you are doing.</p> <p>Default: <code>1</code>.</p>"},{"location":"reference/settings/#tokio_global_queue_interval","title":"tokio_global_queue_interval","text":"<p>Tokio runtime settings. It is strongly recommended not to change this parameter if you do not understand what you are doing.</p> <p>Default: <code>5</code>.</p>"},{"location":"reference/settings/#tokio_event_interval","title":"tokio_event_interval","text":"<p>Tokio runtime settings. It is strongly recommended not to change this parameter if you do not understand what you are doing.</p> <p>Default: <code>1</code>.</p>"},{"location":"reference/settings/#worker_stack_size","title":"worker_stack_size","text":"<p>Tokio runtime settings. It is strongly recommended not to change this parameter if you do not understand what you are doing.</p> <p>Default: <code>8388608</code>.</p>"},{"location":"reference/settings/#connect_timeout","title":"connect_timeout","text":"<p>Connection timeout to server in milliseconds.</p> <p>Default: <code>2000</code> (2 sec).</p>"},{"location":"reference/settings/#idle_timeout","title":"idle_timeout","text":"<p>Server idle timeout in milliseconds.</p> <p>Default: <code>300000</code> (5 min).</p>"},{"location":"reference/settings/#server_lifetime","title":"server_lifetime","text":"<p>Server lifetime in milliseconds.</p> <p>Default: <code>300000</code> (5 min).</p>"},{"location":"reference/settings/#server_round_robin","title":"server_round_robin","text":"<p>In transactional pool mode, we can choose whether the last free server backend will be used or the next one will be selected. By default, the LRU (Least Recently Used) method is used, which has a positive impact on performance.</p> <p>Default: <code>false</code>.</p>"},{"location":"reference/settings/#sync_server_parameters","title":"sync_server_parameters","text":"<p>If enabled, we strive to restore the parameters (via query <code>SET</code>) that were set by the client (and application_name) in transaction mode in other server backends. By default, this is disabled (false) due to performance. If you need to know <code>application_name</code>, but don't want to experience performance issues due to constant server queries <code>SET</code>, you can consider creating a separate pool for each application and using the <code>application_name</code> parameter in the <code>pool</code> settings.</p> <p>Default: <code>false</code>.</p>"},{"location":"reference/settings/#tcp_so_linger","title":"tcp_so_linger","text":"<p>By default, pg_doorman send <code>RST</code> instead of keeping the connection open for a long time.</p> <p>Default: <code>0</code>.</p>"},{"location":"reference/settings/#tcp_no_delay","title":"tcp_no_delay","text":"<p>TCP_NODELAY to disable Nagle's algorithm for lower latency.</p> <p>Default: <code>true</code>.</p>"},{"location":"reference/settings/#tcp_keepalives_count","title":"tcp_keepalives_count","text":"<p>Keepalive enabled by default and overwrite OS defaults.</p> <p>Default: <code>5</code>.</p>"},{"location":"reference/settings/#tcp_keepalives_idle","title":"tcp_keepalives_idle","text":"<p>Default: <code>5</code>.</p>"},{"location":"reference/settings/#tcp_keepalives_interval","title":"tcp_keepalives_interval","text":"<p>Default: <code>1</code>.</p>"},{"location":"reference/settings/#unix_socket_buffer_size","title":"unix_socket_buffer_size","text":"<p>Buffer size for read and write operations when connecting to PostgreSQL via a unix socket.</p> <p>Default: <code>1048576</code>.</p>"},{"location":"reference/settings/#admin_username","title":"admin_username","text":"<p>Access to the virtual admin database is carried out through the administrator's username and password.</p> <p>Default: <code>\"admin\"</code>.</p>"},{"location":"reference/settings/#admin_password","title":"admin_password","text":"<p>Access to the virtual admin database is carried out through the administrator's username and password. It should be replaced with your secret.</p> <p>Default: <code>\"admin\"</code>.</p>"},{"location":"reference/settings/#prepared_statements","title":"prepared_statements","text":"<p>Switcher to enable/disable caching of prepared statements.</p> <p>Default: <code>true</code>.</p>"},{"location":"reference/settings/#prepared_statements_cache_size","title":"prepared_statements_cache_size","text":"<p>Cache size of prepared requests on the server side.</p> <p>Default: <code>8192</code>.</p>"},{"location":"reference/settings/#message_size_to_be_stream","title":"message_size_to_be_stream","text":"<p>Data responses from the server (message type 'D') greater than this value will be transmitted through the proxy in small chunks (1 MB).</p> <p>Default: <code>1048576</code>.</p>"},{"location":"reference/settings/#max_memory_usage","title":"max_memory_usage","text":"<p>We calculate the total amount of memory used by the internal buffers for all current queries. If the limit is reached, the client will receive an error (256 MB).</p> <p>Default: <code>268435456</code>.</p>"},{"location":"reference/settings/#shutdown_timeout","title":"shutdown_timeout","text":"<p>With a graceful shutdown, we wait for transactions to be completed within this time limit (10 seconds).</p> <p>Default: <code>10000</code>.</p>"},{"location":"reference/settings/#hba","title":"hba","text":"<p>The list of IP addresses from which it is permitted to connect to the pg-doorman.</p>"},{"location":"reference/settings/#pooler_check_query","title":"pooler_check_query","text":"<p>This query will not be sent to the server if it is run as a SimpleQuery. It can be used to check the connection at the application level.</p> <p>Default: <code>;</code>.</p>"},{"location":"reference/settings/#pool-settings","title":"Pool Settings","text":"<p>Each record in the pool is the name of the virtual database that the pg-doorman client can connect to.</p> <pre><code>[pools.exampledb] # Declaring the 'exampledb' database\n</code></pre>"},{"location":"reference/settings/#server_host","title":"server_host","text":"<p>The directory with unix sockets or the IPv4 address of the PostgreSQL server that serves this pool.</p> <p>Example: <code>\"/var/run/postgresql\"</code> or <code>\"127.0.0.1\"</code>.</p>"},{"location":"reference/settings/#server_port","title":"server_port","text":"<p>The port through which PostgreSQL server accepts incoming connections.</p> <p>Default: <code>5432</code>.</p>"},{"location":"reference/settings/#server_database","title":"server_database","text":"<p>Optional parameter that determines which database should be connected to on the PostgreSQL server.</p> <p>Example: <code>\"exampledb-2\"</code></p>"},{"location":"reference/settings/#application_name","title":"application_name","text":"<p>Parameter application_name, is sent to the server when opening a connection with postgresql. It may be useful with the sync_server_parameters = false.</p> <p>Example: \"exampledb-pool\".</p>"},{"location":"reference/settings/#pool_mode","title":"pool_mode","text":"<ul> <li> <p><code>session</code> :   Server is released back to pool after client disconnects.</p> </li> <li> <p><code>transaction</code> :   Server is released back to pool after transaction finishes.</p> </li> </ul> <p>Example: <code>\"session\"</code> or <code>\"transaction\"</code>.</p>"},{"location":"reference/settings/#log_client_parameter_status_changes","title":"log_client_parameter_status_changes","text":"<p>Log information about any SET command in the log.</p> <p>Default: <code>false</code>.</p>"},{"location":"reference/settings/#pool-users-settings","title":"Pool Users Settings","text":"<pre><code>[pools.exampledb.users.0]\nusername = \"exampledb-user-0\" # A virtual user who can connect to this virtual database.\n</code></pre>"},{"location":"reference/settings/#username","title":"username","text":"<p>A virtual username who can connect to this virtual database (pool).</p> <p>Example: <code>\"exampledb-user-0\"</code>.</p>"},{"location":"reference/settings/#password","title":"password","text":"<p>The password for the virtual pool user. Password can be specified in <code>MD5</code>, <code>SCRAM-SHA-256</code>, or <code>JWT</code> format. Also, you can create a mirror list of users using secrets from the PostgreSQL instance: <code>select usename, passwd from pg_shadow</code>.</p> <p>Example: <code>md5dd9a0f2...76a09bbfad</code> or <code>SCRAM-SHA-256$4096:E+QNCSW3r58yM+Twj1P5Uw==$LQrKl...Ro1iBKM=</code> or in jwt format: <code>jwt-pkey-fpath:/etc/pg_doorman/jwt/public-exampledb-user.pem</code></p>"},{"location":"reference/settings/#auth_pam_service","title":"auth_pam_service","text":"<p>The pam-service that is responsible for client authorization. In this case, pg_doorman will ignore the <code>password</code> value.</p>"},{"location":"reference/settings/#server_username","title":"server_username","text":"<p>The real server user of the database who connects to this database.</p> <p>Example: <code>\"exampledb_server_user\"</code>.</p>"},{"location":"reference/settings/#server_password","title":"server_password","text":"<p>The password (plain text) of real server user of the database who connects to this database.</p> <p>Example: <code>\"password\"</code>.</p>"},{"location":"reference/settings/#pool_size","title":"pool_size","text":"<p>The maximum number of simultaneous connections to the PostgreSQL server available for this pool and user.</p> <p>Example: <code>40</code>.</p>"},{"location":"tutorials/basic-usage/","title":"Basic Usage","text":"<pre><code>$ pg_doorman --help\n\nPgDoorman: Nextgen PostgreSQL Pooler (based on PgCat)\n\nUsage: pg_doorman [OPTIONS] [CONFIG_FILE]\n\nArguments:\n  [CONFIG_FILE]  [env: CONFIG_FILE=] [default: pg_doorman.toml]\n\nOptions:\n  -l, --log-level &lt;LOG_LEVEL&gt;    [env: LOG_LEVEL=] [default: INFO]\n  -F, --log-format &lt;LOG_FORMAT&gt;  [env: LOG_FORMAT=] [default: text] [possible values: text, structured, debug]\n  -n, --no-color                 disable colors in the log output [env: NO_COLOR=]\n  -d, --daemon                   run as daemon [env: DAEMON=]\n  -h, --help                     Print help\n  -V, --version                  Print version\n</code></pre>"},{"location":"tutorials/basic-usage/#setup-and-running","title":"Setup and Running","text":"<p>First thing you should do is fullfil config file. The configuration file is in \"toml\" format. Some parameters MUST be specified in the configuration file (pg_doorman will not start without it), despite their default values. For example, you MUST specify a admin username and password to access the administrative console.</p> <p>Minimal example to follow is below:     <pre><code>    [general]\n    host = \"0.0.0.0\"\n    port = 6432\n\n    admin_username = \"admin\"\n    admin_password = \"admin\"\n\n    [pools]\n\n    [pools.exampledb]\n    server_host = \"127.0.0.1\"\n    server_port = 5432\n    pool_mode = \"transaction\"\n\n    [pools.exampledb.users.0]\n    pool_size = 40\n    username = \"doorman\"\n    password = \"SCRAM-SHA-256$4096:6nD+Ppi9rgaNyP7...MBiTld7xJipwG/X4=\"\n</code></pre></p> <p>All configuration options are described in Settings Reference Guide. </p> <p>After configuring options, you can run PgDoorman from the command line:</p> <pre><code>$ pg_doorman pg_doorman.toml\n</code></pre> <p>Once launched, you can connect to PgDoorman, instead directly connected to Postgresql database:</p> <pre><code>$ psql -p 6432 -U doorman exampledb\n</code></pre> <p>Managing of PgDoorman can be done by connecting to special administration database pgdoorman:</p> <pre><code>$ psql -p 6432 -U admin pgdoorman\npgdoorman=&gt; show help;\nNOTICE:  Console usage\nDETAIL:\n    SHOW HELP|CONFIG|DATABASES|POOLS|POOLS_EXTENDED|CLIENTS|SERVERS|USERS|VERSION\n    SHOW LISTS\n    SHOW CONNECTIONS\n    SHOW STATS\n    RELOAD\n    SHUTDOWN\n    SHOW\n</code></pre> <p>Also, if you made changes to the pg_doorman.toml file, you can reload it: <pre><code>pgdoorman=# RELOAD;\n</code></pre></p>"},{"location":"tutorials/basic-usage/#command-line-switches","title":"Command line switches","text":"<ul> <li> <p><code>-d</code>, <code>--daemon</code> :   Run in the background. Without it, the process will run in the foreground.</p> <p>In daemon mode, setting <code>daemon_pid_file</code> as well as <code>syslog_prog_name</code> is required.  No log messages will be written to stderr after going into the background.</p> </li> <li> <p><code>-l</code>, <code>--log-level</code> :   Set log-level: <code>INFO</code> or <code>DEBUG</code> or <code>WARN</code>.</p> </li> <li> <p><code>-F</code>, <code>--log-format</code> :   Possible values: text, structured, debug.</p> </li> <li> <p><code>-n</code>, <code>--no-color</code> :   Disable colors in the log output.</p> </li> <li> <p><code>-V</code>, <code>--version</code> :   Show version.</p> </li> <li> <p><code>-h</code>, <code>--help</code> :   Show short help.</p> </li> </ul>"},{"location":"tutorials/basic-usage/#admin-console","title":"Admin console","text":"<p>The console is available by connecting as normal to the database pgdoorman or pgbouncer:</p> <pre><code>$ psql -p 6432 pgdoorman\n</code></pre> <p>Only user <code>admin_username</code> is allowed to log in to the console.</p> <p>Note</p> <p>Admin console currently supports only simple query protocol.  Some drivers use extended query protocol for all of the commands, so these drivers are not suitable.</p>"},{"location":"tutorials/basic-usage/#show-commands","title":"Show commands","text":"<p>The SHOW commands output information. Each command is described below.</p>"},{"location":"tutorials/basic-usage/#show-stats","title":"SHOW STATS","text":"<p>Shows statistics. In this and related commands, the total figures are since process start, the averages are updated every <code>15 seconds</code>.</p> <ul> <li> <p><code>database</code> :   Statistics are presented per database.</p> </li> <li> <p><code>total_xact_count</code> :   Total number of SQL transactions processed by PgDoorman.</p> </li> <li> <p><code>total_query_count</code> :   Total number of SQL commands processed by PgDoorman.</p> </li> <li> <p><code>total_received</code> :   Total volume in bytes of network traffic received by PgDoorman.</p> </li> <li> <p><code>total_sent</code> :   Total volume in bytes of network traffic sent by PgDoorman.</p> </li> <li> <p><code>total_xact_time</code> :   Total number of microseconds spent by PgDoorman when connected     to PostgreSQL in a transaction, either idle in transaction or     executing queries.</p> </li> <li> <p><code>total_query_time</code> :   Total number of microseconds spent by PgDoorman when actively     connected to PostgreSQL, executing queries.</p> </li> <li> <p><code>total_wait_time</code> :   Time spent by clients waiting for a server, in microseconds. Updated     when a client connection is assigned a backend connection.</p> </li> <li> <p><code>avg_xact_count</code> :   Average transactions per second in last stat period.</p> </li> <li> <p><code>avg_query_count</code> :   Average queries per second in last stat period.</p> </li> <li> <p><code>avg_server_assignment_count</code> :   Average number of times a server as assigned to a client per second in the     last stat period.</p> </li> <li> <p><code>avg_recv</code> :   Average received (from clients) bytes per second.</p> </li> <li> <p><code>avg_sent</code> :   Average sent (to clients) bytes per second.</p> </li> <li> <p><code>avg_xact_time</code> :   Average transaction duration, in microseconds.</p> </li> <li> <p><code>avg_query_time</code> :   Average query duration, in microseconds.</p> </li> <li> <p><code>avg_wait_time</code> :   Time spent by clients waiting for a server, in microseconds (average     of the wait times for clients assigned a backend during the current     <code>15 seconds</code>).</p> </li> </ul>"},{"location":"tutorials/basic-usage/#show-servers","title":"SHOW SERVERS","text":"<ul> <li> <p><code>server_id</code> :   Unique ID for server.</p> </li> <li> <p><code>server_process_id</code> :   PID of backend server process.  In case connection is made over     Unix socket and OS supports getting process ID info, its     OS PID.</p> </li> <li> <p><code>database_name</code> :   Database name.</p> </li> <li> <p><code>user</code> :   User name PgDoorman uses to connect to server.</p> </li> <li> <p><code>application_name</code> :   A string containing the <code>application_name</code> set on the server connection.</p> </li> <li> <p><code>state</code> :   State of the pg_doorman server connection, one of active,     idle, used.</p> </li> <li> <p><code>wait</code> :   Wait state of the pg_doorman server connection, one of idle,     read, write.</p> </li> <li> <p><code>transaction_count</code> :   Total number of processed transactions.</p> </li> <li> <p><code>query_count</code> :   Total number of processed queries.</p> </li> <li> <p><code>bytes_sent</code> :   Total bytes sent to PostgreSQL server.</p> </li> <li> <p><code>bytes_received</code> :   Total bytes received from PostgreSQL server.</p> </li> <li> <p><code>age_seconds</code> :   Lifetime of the current server connection.</p> </li> <li> <p><code>prepare_cache_hit</code> :   Total number of cache hit prepared statements.</p> </li> <li> <p><code>prepare_cache_miss</code> :   Total number of cache miss prepared statements.</p> </li> <li> <p><code>prepare_cache_size</code> :   The total number of unique prepared statements.</p> </li> </ul>"},{"location":"tutorials/basic-usage/#show-clients","title":"SHOW CLIENTS","text":"<ul> <li> <p><code>client_id</code> :   Unique ID for client.</p> </li> <li> <p><code>database</code> :   Database (pool) name.</p> </li> <li> <p><code>user</code> :   Client connected user.</p> </li> <li> <p><code>addr</code> :   IP:port of client.</p> </li> <li> <p><code>tls</code> :   Can be true, false.</p> </li> <li> <p><code>state</code> :   State of the client connection, one of active,     idle, waiting.</p> </li> <li> <p><code>wait</code> :   Wait state of the pg_doorman client connection, one of idle,     read, write.</p> </li> <li> <p><code>transaction_count</code> :   Total number of processed transactions.</p> </li> <li> <p><code>query_count</code> :   Total number of processed queries.</p> </li> <li> <p><code>age_seconds</code> :   Lifetime of the current client connection.</p> </li> </ul>"},{"location":"tutorials/basic-usage/#show-pools","title":"SHOW POOLS","text":"<p>A new pool entry is made for each couple of (database, user).</p> <ul> <li> <p><code>database</code> :   Database name.</p> </li> <li> <p><code>user</code> :   User name.</p> </li> <li> <p><code>pool_mode</code> :   The pooling mode in use.</p> </li> <li> <p><code>cl_active</code> :   Client connections that are either linked to server connections or are idle with no queries waiting to be processed.</p> </li> <li> <p><code>cl_waiting</code> :   Client connections that have sent queries but have not yet got a server connection.</p> </li> <li> <p><code>sv_active</code> :   Server connections that are linked to a client.</p> </li> <li> <p><code>sv_idle</code> :   Server connections that are unused and immediately usable for client queries.</p> </li> <li> <p><code>sv_login</code> :   Server connections currently in the process of logging in.</p> </li> <li> <p><code>maxwait</code> :   How long the first (oldest) client in the queue has waited, in seconds.     If this starts increasing, then the current pool of servers does     not handle requests quickly enough.  The reason may be either an overloaded     server or just too small of a pool_size setting.</p> </li> <li> <p><code>maxwait_us</code> :   Microsecond part of the maximum waiting time.</p> </li> </ul>"},{"location":"tutorials/basic-usage/#show-users","title":"SHOW USERS","text":"<ul> <li> <p><code>name</code> :   The user name</p> </li> <li> <p><code>pool_mode</code> :   The pooling mode in use.</p> </li> </ul>"},{"location":"tutorials/basic-usage/#show-databases","title":"SHOW DATABASES","text":"<ul> <li> <p><code>database</code> :   Name of configured database entry.</p> </li> <li> <p><code>host</code> :   Host pg_doorman connects to.</p> </li> <li> <p><code>port</code> :   Port pg_doorman connects to.</p> </li> <li> <p><code>pool_size</code> :   Maximum number of server connections.</p> </li> <li> <p><code>min_pool_size</code> :   Minimum number of server connections.</p> </li> <li> <p><code>reserve_pool_size</code> :   Maximum number of additional connections for this database.</p> </li> <li> <p><code>pool_mode</code> :   The pooling mode in use.</p> </li> <li> <p><code>max_connections</code> :   Maximum number of allowed server connections for this database, as set by     max_db_connections, either globally or per database.</p> </li> <li> <p><code>current_connections</code> :   Current number of server connections for this database.</p> </li> </ul>"},{"location":"tutorials/basic-usage/#show-sockets","title":"SHOW SOCKETS","text":"<p>Shows low-level information about sockets or only active sockets. This includes the information shown under SHOW CLIENTS and SHOW SERVERS as well as other more low-level information.</p>"},{"location":"tutorials/basic-usage/#show-version","title":"SHOW VERSION","text":"<p>Show the PgDoorman version string.</p>"},{"location":"tutorials/basic-usage/#shutdown","title":"SHUTDOWN","text":"<p>The PgDoorman process will exit.</p>"},{"location":"tutorials/basic-usage/#reload","title":"RELOAD","text":"<p>The PgDoorman process will reload its configuration files and update changeable settings.</p> <p>PgDoorman notices when a configuration file reload changes the connection parameters of a database definition.  An existing server connection to the old destination will be closed when the server connection is next released (according to the pooling mode), and new server connections will immediately use the updated connection parameters.</p>"},{"location":"tutorials/basic-usage/#signals","title":"Signals","text":"<ul> <li> <p>SIGHUP :   Reload config. Same as issuing the command RELOAD on the console.</p> </li> <li> <p>SIGTERM :   Immediate shutdown.</p> </li> <li> <p>SIGINT :   Graceful shutdown looks here for more information.</p> </li> </ul>"},{"location":"tutorials/binary-upgrade/","title":"How to upgrade","text":""},{"location":"tutorials/binary-upgrade/#binary-upgrade","title":"Binary upgrade","text":"<p>When you send a <code>SIGINT</code> signal to the pg_doorman process, the binary upgrade begins. The old pg_doorman instance executes the exec command and starts a new, daemonized process. This new process uses the <code>SO_REUSE_PORT</code> parameter, and the operating system sends traffic to the new instance. After that, the old instance closes its socket for incoming connections.</p> <p>We then give the option to complete any current queries and transactions within the specified <code>shutdown_timeout</code> (10 seconds). After successful completion of each query or transaction, we return an error code <code>58006</code> to the client, indicating that they need to reconnect. After reconnecting, the client can safely retry their queries.</p> <p>Warning</p> <p>Repeating query (without code <code>58006</code>) may cause problems as described in issue</p> <p>Tip</p> <p>Be careful when using <code>github.com/lib/pq</code> or <code>database/sql</code>.</p>"},{"location":"tutorials/contributing/","title":"Contributing","text":""},{"location":"tutorials/contributing/#local-development","title":"Local development","text":"<ol> <li>Install Rust (the latest stable version will work great)</li> <li>Run <code>cargo build --release</code> to get better benchmarks.</li> <li>Adjust the configuration in <code>pg_doorman.toml</code> to match your setup (this step is optional, given next).</li> <li>Execute <code>cargo run --release</code>. You're now ready to go!</li> <li>Also, you can use <code>make docker-compose-test-all</code> for testing with docker.</li> </ol>"},{"location":"tutorials/installation/","title":"Installing PgDoorman","text":"<p>As first class option, you can obtain PgDoorman distribution via GitHub releases.</p> <p>Any other option implies, that you have already cloned project with Git:</p> <p><code>git clone https://github.com/ozontech/pg_doorman.git</code></p>"},{"location":"tutorials/installation/#docker","title":"Docker","text":"<pre><code>docker build -t pg_doorman -f Dockerfile .\ndocker run -p 6432:6432 -v /path/to/pg_doorman.toml:/etc/pg_doorman/pg_doorman.toml --rm -t -i pg_doorman\n</code></pre>"},{"location":"tutorials/installation/#nix-docker","title":"Nix (Docker)","text":"<pre><code>nix build .#dockerImage\ndocker load -i result\ndocker run -p 6432:6432 -v /path/to/pg_doorman.toml:/etc/pg_doorman/pg_doorman.toml --rm -t -i pg_doorman\n</code></pre>"},{"location":"tutorials/installation/#dockerpodman-compose","title":"Docker/Podman Compose","text":"<p>Discover minimal compose configuration file in the repository directory</p>"},{"location":"tutorials/installation/#running-docker-compose","title":"Running Docker Compose","text":"<pre><code>docker compose up -d\n</code></pre>"},{"location":"tutorials/installation/#running-podman-compose","title":"Running Podman Compose","text":"<pre><code>podman-compose up -d\n</code></pre>"},{"location":"tutorials/overview/","title":"Overview","text":"<p>PgDoorman is a PostgreSQL connection pooler. Any application can consider connection to PgDoorman as if it were a  connection to Postgresql server. PgDoorman will create a connection to the actual server or will reuse an existed connection.</p> <p>In order not to compromise transaction semantics for connection  pooling, PgDoorman supports several types of pooling when rotating connections.</p>"},{"location":"tutorials/overview/#session-pooling","title":"Session pooling","text":"<p>Client gets an assigned server connection for the lifetime of the client connection. After the client disconnects, server connection will be released back into the pool.</p>"},{"location":"tutorials/overview/#transaction-pooling","title":"Transaction pooling","text":"<p>Client gets an assigned server connection only for the duration of transaction. After PgDoorman notices the end of the transaction, connection will be released back into the pool.</p>"},{"location":"tutorials/overview/#managing","title":"Managing","text":"<p>You can manage PgDoorman via Admin Console</p>"}]}