name: Publish to Launchpad PPA

on:
  pull_request:
  release:
    types: [published]

permissions:
  contents: read

env:
  # Ubuntu LTS versions (non-EOL)
  UBUNTU_VERSIONS: "jammy noble plucky"
  # jammy = 22.04 LTS
  # noble = 24.04 LTS  
  # plucky = 25.04
  PPA_NAME: "ppa:vadv/pg-doorman"
  RUST_VERSION: "1.87.0"
  # Rebuild number for Launchpad PPA uploads
  # Increment this when you need to re-upload the same version
  # (e.g., after fixing packaging issues without changing the actual version)
  # Set to empty string "" for first upload of a version
  REBUILD_NUMBER: "2"

jobs:
  verify-version:
    name: Verify tag version matches Cargo.toml
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get_version.outputs.version }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      - name: Get and verify version
        id: get_version
        run: |
          # Extract version from Cargo.toml
          CARGO_VERSION=$(grep '^version =' Cargo.toml | head -1 | cut -d '"' -f2)
          echo "Cargo.toml version: $CARGO_VERSION"
          
          # For release events, verify tag matches Cargo.toml version
          if [ "${{ github.event_name }}" = "release" ]; then
            # Extract version from git tag (remove 'v' prefix)
            TAG_VERSION=${GITHUB_REF_NAME#v}
            echo "Git tag version: $TAG_VERSION"
            
            # Compare versions
            if [ "$CARGO_VERSION" != "$TAG_VERSION" ]; then
              echo "Error: Version mismatch between Cargo.toml ($CARGO_VERSION) and git tag ($TAG_VERSION)"
              exit 1
            fi
          else
            echo "Pull request build - skipping tag verification"
          fi
          
          echo "version=$CARGO_VERSION" >> $GITHUB_OUTPUT

  prepare-source-packages:
    name: Prepare source packages for Launchpad
    needs: [verify-version]
    if: github.event.pull_request.head.repo.full_name == github.repository
    runs-on: ubuntu-latest
    container:
      image: ubuntu:24.04
      env:
        DEBIAN_FRONTEND: noninteractive
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install build dependencies
        run: |
          # Retry logic to handle transient mirror issues
          install_packages() {
            apt-get update && apt-get install -y \
              git \
              devscripts \
              debhelper \
              gnupg \
              wget \
              build-essential \
              pkg-config \
              libssl-dev \
              cmake \
              clang \
              g++ \
              ca-certificates
          }
          
          # Try up to 3 times with increasing delays
          for i in 1 2 3; do
            if install_packages; then
              echo "Package installation succeeded on attempt $i"
              break
            else
              if [ $i -lt 3 ]; then
                echo "Package installation failed on attempt $i, retrying in $((i * 30)) seconds..."
                sleep $((i * 30))
              else
                echo "Package installation failed after 3 attempts"
                exit 1
              fi
            fi
          done

      - name: Install Rust
        run: |
          wget -q https://static.rust-lang.org/dist/rust-${{ env.RUST_VERSION }}-x86_64-unknown-linux-gnu.tar.gz -O /tmp/rust.tar.gz
          cd /tmp && tar xf rust.tar.gz && ./rust-*-x86_64-unknown-linux-gnu/install.sh

      - name: Import GPG key and verify passphrase
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PRIVATE_KEY_PASSWORD }}
        run: |
          # Configure GPG for non-interactive use BEFORE importing key
          mkdir -p ~/.gnupg
          chmod 700 ~/.gnupg
          echo "use-agent" > ~/.gnupg/gpg.conf
          echo "pinentry-mode loopback" >> ~/.gnupg/gpg.conf
          echo "allow-loopback-pinentry" > ~/.gnupg/gpg-agent.conf
          echo "RELOADAGENT" | gpg-connect-agent || true
          
          # Import GPG key
          printf '%s' "$GPG_PRIVATE_KEY" | gpg --batch --no-tty --import
          
          # Get the key ID
          GPG_KEY_ID=$(gpg --list-secret-keys --keyid-format LONG | grep sec | head -1 | awk '{print $2}' | cut -d'/' -f2)
          echo "GPG_KEY_ID=$GPG_KEY_ID" >> $GITHUB_ENV
          echo "Using GPG key: $GPG_KEY_ID"
          
          # Trust the key automatically without TTY
          echo -e "5\ny\n" | gpg --batch --no-tty --command-fd 0 --expert --edit-key $GPG_KEY_ID trust
          
          # Verify passphrase works by signing a test message
          echo "Verifying GPG passphrase..."
          echo "test message" > /tmp/gpg_test.txt
          if ! gpg --batch --no-tty --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" --sign /tmp/gpg_test.txt; then
            echo "ERROR: GPG passphrase verification failed!"
            echo "Please check that GPG_PRIVATE_KEY_PASSWORD secret is correct and has no extra whitespace/newlines"
            exit 1
          fi
          rm -f /tmp/gpg_test.txt /tmp/gpg_test.txt.gpg
          echo "GPG passphrase verified successfully!"

      - name: Create vendor tarball
        run: |
          cargo vendor
          tar czf vendor.tar.gz vendor/

      - name: Download Rust tarball for offline build
        run: |
          # Download Rust tarball that will be included in source package for offline Launchpad builds
          wget -q https://static.rust-lang.org/dist/rust-${{ env.RUST_VERSION }}-x86_64-unknown-linux-gnu.tar.gz -O rust-${{ env.RUST_VERSION }}-x86_64-unknown-linux-gnu.tar.gz
          echo "Downloaded Rust tarball:"
          ls -la rust-*.tar.gz

      - name: Build source packages for each Ubuntu version
        env:
          VERSION: ${{ needs.verify-version.outputs.version }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PRIVATE_KEY_PASSWORD }}
          REBUILD_NUMBER: ${{ env.REBUILD_NUMBER }}
        run: |
          set -e
          
          # Construct package version with optional rebuild suffix
          # Format: VERSION+rebuildN~DISTRO (e.g., 3.0.0+rebuild1~jammy)
          # If REBUILD_NUMBER is empty, no suffix is added
          if [ -n "$REBUILD_NUMBER" ]; then
            PKG_VERSION="${VERSION}+rebuild${REBUILD_NUMBER}"
            echo "Package version with rebuild suffix: $PKG_VERSION"
          else
            PKG_VERSION="${VERSION}"
            echo "Package version (no rebuild suffix): $PKG_VERSION"
          fi
          
          # Verify all required tools are installed
          echo "Verifying required tools..."
          for tool in debuild gpg tar; do
            if ! which $tool > /dev/null 2>&1; then
              echo "Error: Required tool '$tool' is not installed"
              exit 1
            fi
            echo "  $tool: $(which $tool)"
          done
          echo "All required tools are available"
          
          # Create output directory for all packages
          mkdir -p /tmp/packages
          
          # Save the source directory to return to it after each iteration
          SOURCE_DIR=$(pwd)
          
          for DISTRO in $UBUNTU_VERSIONS; do
            echo "=========================================="
            echo "Building for Ubuntu $DISTRO"
            echo "=========================================="
            
            # Ensure we're in the source directory
            cd "$SOURCE_DIR"
            
            # Create a clean working directory
            WORK_DIR=$(mktemp -d)
            mkdir -p "$WORK_DIR/pg-doorman-${VERSION}"
            
            # Define what we want to package (explicit list instead of excludes)
            # These are the actual project files needed for building
            # Rust tarball is included for offline installation (Launchpad has no network access)
            RUST_TARBALL="rust-${{ env.RUST_VERSION }}-x86_64-unknown-linux-gnu.tar.gz"
            FILES_TO_COPY="Cargo.toml Cargo.lock src patches benches debian vendor.tar.gz rust-toolchain.toml $RUST_TARBALL"
            
            # Debug: show what we're going to copy
            echo "Files/directories to copy:"
            for item in $FILES_TO_COPY; do
              if [ -e "$item" ]; then
                echo "  [OK] $item"
              else
                echo "  [MISSING] $item"
              fi
            done
            
            # Copy only the specified files/directories
            for item in $FILES_TO_COPY; do
              if [ -e "$item" ]; then
                cp -r "$item" "$WORK_DIR/pg-doorman-${VERSION}/"
              fi
            done
            
            cd "$WORK_DIR/pg-doorman-${VERSION}"
            
            # Include vendor directory for offline build
            tar xzf vendor.tar.gz
            
            # Replace .cargo-checksum.json files with empty checksums to avoid verification issues
            # Some crates (like vcpkg) contain test data with symlinks/special files
            # that don't survive tar archiving, causing checksum mismatches
            # We keep the files but clear the "files" checksums while preserving package checksum
            for checksum_file in $(find vendor -name '.cargo-checksum.json'); do
              # Extract package checksum and create new file with empty files checksums
              pkg_checksum=$(grep -o '"package":"[^"]*"' "$checksum_file" | head -1 || echo '"package":null')
              echo "{\"files\":{},${pkg_checksum}}" > "$checksum_file"
            done
            
            # Generate changelog for this distribution
            cat > debian/changelog << EOF
          pg-doorman (${PKG_VERSION}~${DISTRO}) ${DISTRO}; urgency=medium

            * Release version ${VERSION}
            * PostgreSQL connection pooler and proxy
            * Includes pg_doorman and patroni_proxy binaries

           -- Dmitry Vasiliev <vadv-ya@yandex.ru>  $(date -R)
          EOF
            
            # Create the source package
            cd "$WORK_DIR"
            tar czf "pg-doorman_${PKG_VERSION}~${DISTRO}.orig.tar.gz" "pg-doorman-${VERSION}"
            cd "pg-doorman-${VERSION}"
            
            # Build source package (unsigned first, then sign manually)
            # Using dpkg-buildpackage directly to avoid debsign TTY issues
            # -d flag ignores Build-Depends check (Rust >= 1.75 comes from PPA on Launchpad)
            dpkg-buildpackage -d -us -uc -ui -S -sa
            
            # Sign the .dsc and .changes files manually with gpg
            cd "$WORK_DIR"
            debsign -k${{ env.GPG_KEY_ID }} --no-re-sign -p"gpg --batch --no-tty --pinentry-mode loopback --passphrase '$GPG_PASSPHRASE'" pg-doorman_${PKG_VERSION}~${DISTRO}_source.changes
            
            # Copy built packages to output directory
            cp "$WORK_DIR"/pg-doorman_${PKG_VERSION}~${DISTRO}* /tmp/packages/
            
            # Cleanup working directory
            rm -rf "$WORK_DIR"
            
            echo "Successfully built package for Ubuntu $DISTRO"
          done
          
          echo "=========================================="
          echo "All packages built successfully"
          echo "=========================================="
          ls -la /tmp/packages/

      - name: Upload source packages artifact
        uses: actions/upload-artifact@v4
        with:
          name: launchpad-source-packages
          path: /tmp/packages/

  upload-to-launchpad:
    name: Upload to Launchpad PPA
    needs: [verify-version, prepare-source-packages]
    if: github.event_name == 'release'
    runs-on: ubuntu-latest
    container:
      image: ubuntu:24.04
      env:
        DEBIAN_FRONTEND: noninteractive
    steps:
      - name: Download source packages
        uses: actions/download-artifact@v4
        with:
          name: launchpad-source-packages
          path: /tmp/packages

      - name: Install SFTP dependencies
        run: |
          apt-get update && apt-get install -y gnupg openssh-client

      - name: Setup SSH key for Launchpad SFTP
        env:
          LAUNCHPAD_SSH_KEY: ${{ secrets.LAUNCHPAD_SSH_KEY }}
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Save SSH key
          echo "$LAUNCHPAD_SSH_KEY" > ~/.ssh/id_launchpad
          chmod 600 ~/.ssh/id_launchpad
          
          # Get host keys from Launchpad
          ssh-keyscan -H ppa.launchpad.net >> ~/.ssh/known_hosts 2>/dev/null || true
          
          echo "SSH key configured for Launchpad SFTP upload"

      - name: Import GPG key
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        run: |
          echo "$GPG_PRIVATE_KEY" | gpg --batch --no-tty --import
          GPG_KEY_ID=$(gpg --list-secret-keys --keyid-format LONG | grep sec | head -1 | awk '{print $2}' | cut -d'/' -f2)
          echo "GPG_KEY_ID=$GPG_KEY_ID" >> $GITHUB_ENV

      - name: Verify GPG signatures before upload
        env:
          VERSION: ${{ needs.verify-version.outputs.version }}
          REBUILD_NUMBER: ${{ env.REBUILD_NUMBER }}
        run: |
          set -e
          
          # Construct package version with optional rebuild suffix
          if [ -n "$REBUILD_NUMBER" ]; then
            PKG_VERSION="${VERSION}+rebuild${REBUILD_NUMBER}"
          else
            PKG_VERSION="${VERSION}"
          fi
          
          cd /tmp/packages
          
          echo "=========================================="
          echo "Verifying GPG signatures on all packages"
          echo "=========================================="
          
          VERIFICATION_FAILED=0
          
          # Function to verify GPG signature and check for errors in output
          verify_signature() {
            local file="$1"
            local output
            local exit_code
            
            # Capture both stdout and stderr, and exit code
            output=$(gpg --verify "$file" 2>&1) || exit_code=$?
            
            # Check for errors in output (SignatureVerifyError, BAD signature, etc.)
            if echo "$output" | grep -qiE "(Error|BAD|failed|cannot)"; then
              echo "ERROR: GPG verification output contains errors for $file:"
              echo "$output"
              return 1
            fi
            
            # Also check exit code
            if [ "${exit_code:-0}" -ne 0 ]; then
              echo "ERROR: GPG verification failed with exit code $exit_code for $file:"
              echo "$output"
              return 1
            fi
            
            # Check for "Good signature" in output
            if ! echo "$output" | grep -qi "Good signature"; then
              echo "ERROR: No 'Good signature' found for $file:"
              echo "$output"
              return 1
            fi
            
            echo "OK: $file - Good signature verified"
            return 0
          }
          
          for DISTRO in $UBUNTU_VERSIONS; do
            echo "Verifying signature for Ubuntu $DISTRO..."
            
            # Verify .dsc file signature
            DSC_FILE="pg-doorman_${PKG_VERSION}~${DISTRO}.dsc"
            if ! verify_signature "$DSC_FILE"; then
              VERIFICATION_FAILED=1
            fi
            
            # Verify .changes file signature
            CHANGES_FILE="pg-doorman_${PKG_VERSION}~${DISTRO}_source.changes"
            if ! verify_signature "$CHANGES_FILE"; then
              VERIFICATION_FAILED=1
            fi
          done
          
          if [ $VERIFICATION_FAILED -eq 1 ]; then
            echo "=========================================="
            echo "ERROR: GPG signature verification failed!"
            echo "=========================================="
            echo ""
            echo "This usually means the GPG public key is not registered in Launchpad."
            echo "Please follow these steps:"
            echo "1. Export your public key: gpg --armor --export ${{ env.GPG_KEY_ID }}"
            echo "2. Upload key to keyserver: gpg --keyserver keyserver.ubuntu.com --send-keys ${{ env.GPG_KEY_ID }}"
            echo "3. Add key to Launchpad: https://launchpad.net/~/+editpgpkeys"
            echo "4. Verify the key via email confirmation from Launchpad"
            echo ""
            exit 1
          fi
          
          echo "=========================================="
          echo "All GPG signatures verified successfully"
          echo "=========================================="

      - name: Upload source packages to Launchpad PPA
        if: github.event_name == 'release'
        env:
          VERSION: ${{ needs.verify-version.outputs.version }}
          REBUILD_NUMBER: ${{ env.REBUILD_NUMBER }}
        run: |
          set -e
          
          # Construct package version with optional rebuild suffix
          if [ -n "$REBUILD_NUMBER" ]; then
            PKG_VERSION="${VERSION}+rebuild${REBUILD_NUMBER}"
          else
            PKG_VERSION="${VERSION}"
          fi
          
          cd /tmp/packages
          
          # Function to upload all files for a distribution in a SINGLE SFTP session
          # This is critical because Launchpad processes .changes file immediately
          # and expects all referenced files to be present in the same upload session
          upload_distro_package() {
            local distro="$1"
            local version="$2"
            local max_attempts=5
            local attempt=1
            local delay=10
            
            echo "Uploading files for Ubuntu $distro..."
            
            # Get list of files from .changes file
            local changes_file="pg-doorman_${version}~${distro}_source.changes"
            
            if [ ! -f "$changes_file" ]; then
              echo "ERROR: Changes file not found: $changes_file"
              return 1
            fi
            
            # Extract files to upload from .changes file (Files: section)
            # Format: checksum size section priority filename
            local files_to_upload=""
            local in_files_section=0
            
            while IFS= read -r line; do
              if echo "$line" | grep -q "^Files:"; then
                in_files_section=1
                continue
              fi
              if [ $in_files_section -eq 1 ]; then
                # Check if line starts with space (continuation of Files section)
                if echo "$line" | grep -q "^ "; then
                  # Extract filename (last field)
                  local filename
                  filename=$(echo "$line" | awk '{print $NF}')
                  files_to_upload="$files_to_upload $filename"
                else
                  # End of Files section
                  break
                fi
              fi
            done < "$changes_file"
            
            # Add the .changes file itself (must be uploaded LAST)
            files_to_upload="$files_to_upload $changes_file"
            
            echo "Files to upload: $files_to_upload"
            
            # Verify all files exist before attempting upload
            for file in $files_to_upload; do
              if [ ! -f "$file" ]; then
                echo "ERROR: Required file not found: $file"
                return 1
              fi
            done
            
            # Create SFTP batch file to upload ALL files in a single session
            # This ensures Launchpad can find all files when processing .changes
            # IMPORTANT: Use full path in put command to upload to PPA, not main archive
            # Note: cd command doesn't work on Launchpad SFTP, so we specify full remote path
            local batch_file=$(mktemp)
            local remote_dir="~vadv/pg-doorman/ubuntu"
            for file in $files_to_upload; do
              echo "put $file ${remote_dir}/${file}" >> "$batch_file"
            done
            
            echo "SFTP batch commands:"
            cat "$batch_file"
            
            # Upload with retry logic
            while [ $attempt -le $max_attempts ]; do
              echo "Upload attempt $attempt of $max_attempts..."
              
              if sftp -i ~/.ssh/id_launchpad -o BatchMode=yes -o StrictHostKeyChecking=accept-new -b "$batch_file" vadv@ppa.launchpad.net; then
                echo "Successfully uploaded all files for $distro"
                rm -f "$batch_file"
                return 0
              else
                if [ $attempt -lt $max_attempts ]; then
                  echo "Upload failed, retrying in ${delay} seconds..."
                  sleep $delay
                  delay=$((delay + 10))
                else
                  echo "Failed to upload files for $distro after $max_attempts attempts"
                  rm -f "$batch_file"
                  return 1
                fi
              fi
              
              attempt=$((attempt + 1))
            done
          }
          
          for DISTRO in $UBUNTU_VERSIONS; do
            echo "=========================================="
            echo "Uploading package for Ubuntu $DISTRO"
            echo "=========================================="
            
            if ! upload_distro_package "$DISTRO" "$PKG_VERSION"; then
              echo "ERROR: Failed to upload package for Ubuntu $DISTRO"
              exit 1
            fi
            
            echo "Successfully uploaded package for Ubuntu $DISTRO"
          done
          
          echo "=========================================="
          echo "All packages uploaded to Launchpad PPA"
          echo "=========================================="
