# Step 5: SCRAM-SHA-256 support

## Goal

Support SCRAM-SHA-256 authentication for auth_query users. Extract `ClientKey`
from client's SCRAM proof for later use in passthrough mode (Step 6).

## Dependencies

- Step 4 (auth flow integration)

## 5.1 ClientKey extraction

### File: `src/auth/scram.rs`

Current `prepare_server_final_message()` verifies the client proof but doesn't
extract `ClientKey`. We need to add extraction.

The math (already in design doc):
```
ClientSignature = HMAC(StoredKey, AuthMessage)
ClientKey = ClientProof XOR ClientSignature
```

Modify `prepare_server_final_message()` to return `ClientKey` alongside the
server final message. Or add a separate function:

```rust
/// Extract ClientKey from client's SCRAM proof.
/// Used for SCRAM passthrough to backend PostgreSQL.
pub fn extract_client_key(
    client_proof: &[u8],
    stored_key: &[u8],
    auth_message: &str,
) -> Vec<u8> {
    let client_signature = compute_hmac(stored_key, auth_message.as_bytes());
    // ClientKey = ClientProof XOR ClientSignature
    client_proof
        .iter()
        .zip(client_signature.iter())
        .map(|(p, s)| p ^ s)
        .collect()
}
```

Need to verify correctness: `H(ClientKey) == StoredKey` (this is the standard
SCRAM verification). If it matches, we know the extracted ClientKey is correct.

```rust
pub fn verify_client_key(client_key: &[u8], stored_key: &[u8]) -> bool {
    let computed_stored_key = Sha256::digest(client_key);
    computed_stored_key.as_slice() == stored_key
}
```

## 5.2 SCRAM auth in auth_query flow

### File: `src/auth/mod.rs`

In `try_auth_query()`, add SCRAM branch:

```rust
if pool_password.starts_with(SCRAM_SHA_256) {
    let client_key = authenticate_with_scram_aq(
        read, write, pool_password, username
    ).await?;
    // Store client_key in session for passthrough (Step 6)
    // For now, just authenticate
} else if pool_password.starts_with(MD5_PASSWORD_PREFIX) {
    authenticate_with_md5_aq(read, write, pool_password, username).await?;
}
```

`authenticate_with_scram_aq()` is similar to existing `authenticate_with_scram()`
but additionally extracts and returns `ClientKey`:

```rust
async fn authenticate_with_scram_aq<S, T>(
    read: &mut S,
    write: &mut T,
    pool_password: &str,
    username: &str,
) -> Result<Option<Vec<u8>>, Error>  // Returns ClientKey
{
    let server_secret = parse_server_secret(pool_password)?;

    // SCRAM handshake (same as existing)
    scram_start_challenge(write).await?;
    let first_msg = read_password(read).await?;
    let client_first = parse_client_first_message(...)?;
    let server_first = prepare_server_first_response(
        &client_first.nonce,
        &client_first.client_first_bare,
        &server_secret.salt_base64,
        server_secret.iteration,
    );
    scram_server_response(write, SASL_CONTINUE, &server_first.server_first_bare).await?;
    let final_msg = read_password(read).await?;
    let client_final = parse_client_final_message(...)?;

    // Verify and extract ClientKey
    let server_final = prepare_server_final_message(
        client_first, client_final, server_first,
        server_secret.server_key, server_secret.stored_key.clone(),
    )?;

    // Extract ClientKey from proof (after successful verification)
    let client_key = extract_client_key(
        &client_final.proof,
        &server_secret.stored_key,
        &auth_message,  // Need to reconstruct or pass through
    );

    scram_server_response(write, SASL_FINAL, &server_final).await?;
    Ok(Some(client_key))
}
```

**Note:** The current `prepare_server_final_message()` consumes the client_first
and client_final messages. We need access to `client_final.proof` and the
`auth_message` after verification. May need to refactor the function to return
these alongside the server final message, or extract ClientKey inside it.

## 5.3 SCRAM password rotation handling

On SCRAM auth failure with stale cache (Decision from Problem 1):

```rust
// In try_auth_query(), after SCRAM auth failure:
// The salt in ServerFirst was from the OLD verifier.
// Client's proof is bound to old salt — can't retry with new verifier.
// Invalidate cache and reject. Client must reconnect.
aq_state.cache.invalidate(username);
wrong_password(write, username).await?;
Err(Error::AuthError("SCRAM auth failed, cache invalidated — please reconnect".into()))
```

For MD5 (already in Step 4): salt was generated by pg_doorman, not from
pg_shadow. Re-fetch gives new md5 hash, recompute `md5(hash + salt)` — works.

## 5.4 ClientKey storage

**Fix (Problem C):** ClientKey is stored in two places:

1. **`CacheEntry.client_key`** — in the auth_query cache. Updated via
   `cache.set_client_key(username, client_key)` after successful SCRAM auth.
   This allows pool connections created asynchronously later (by the pool
   manager) to retrieve the ClientKey for backend SCRAM passthrough.

2. **`AuthQueryAuthResult.client_key`** — returned from `try_auth_query()`
   (see Step 4 fix for Problem B). Used immediately by the current auth flow.

```rust
// In try_auth_query(), after successful SCRAM auth:
let client_key = authenticate_with_scram_aq(read, write, pool_password, username).await?;
if let Some(ref ck) = client_key {
    aq_state.cache.set_client_key(username, ck.clone());
}

// Return in AuthQueryAuthResult:
Ok(AuthQueryAuthResult {
    pool,
    server_parameters,
    client_key,
})
```

**Lifetime consideration:** The ClientKey in the cache entry survives as long
as the cache entry (up to `cache_ttl`). If the entry is evicted or invalidated,
new SCRAM auth re-extracts the ClientKey. For passthrough mode (Step 6), the
`BackendAuthMethod` on the pool's `User` struct stores a copy of the ClientKey
so it remains available even after cache eviction.

## 5.5 BDD tests

```gherkin
@auth-query @scram
Scenario: Auth query SCRAM — valid password
  Given pg_doorman configured with auth_query, PG uses scram-sha-256
  And user "scram_user" exists with SCRAM password
  When client connects as "scram_user" with correct password using SCRAM
  Then authentication succeeds

@auth-query @scram
Scenario: Auth query SCRAM — wrong password
  Given pg_doorman configured with auth_query, PG uses scram-sha-256
  When client connects as "scram_user" with wrong password using SCRAM
  Then authentication fails

@auth-query @scram
Scenario: SCRAM password rotation — requires reconnect
  Given "scram_user" SCRAM verifier is cached
  When password is changed in PG (new salt)
  And client connects with new password
  Then authentication fails (old salt in ServerFirst)
  And cache is invalidated
  When client reconnects with new password
  Then new verifier fetched, authentication succeeds
```

## Checklist

- [ ] `extract_client_key()` in `scram.rs`
- [ ] `verify_client_key()` sanity check
- [ ] SCRAM branch in `try_auth_query()`
- [ ] ClientKey returned from SCRAM auth
- [ ] SCRAM password rotation: invalidate + reject
- [ ] Refactor `prepare_server_final_message()` if needed for ClientKey access
- [ ] BDD tests (3+)
- [ ] `cargo fmt && cargo clippy -- --deny "warnings"`
